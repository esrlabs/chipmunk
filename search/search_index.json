{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p><code>chipmunk</code> is one of the fastest desktop applications for viewing log files, with no limitations on file size. 1 GB, 2 GB, 10 GB? <code>chipmunk</code> is limited only by your disk space - nothing more. With no caching and no unnecessary copying, files of any size open with the same speed. But <code>chipmunk</code> goes beyond just working with files: it also allows you to create network connections to collect logs via TCP, UDP, Serial, or from the output of a running command.</p>"},{"location":"#automotive-and-network-traces","title":"Automotive and Network Traces","text":"<p>Out of the box, <code>chipmunk</code> supports several formats critical for the automotive industry, including DLT and SomeIp. Unlike many alternatives, <code>chipmunk</code> offers full trace inspection capabilities for DLT, including support for embedded attachments. Media files (images, video, audio) and text can be viewed directly within <code>chipmunk</code> or exported to disk.</p> <p>Additionally, <code>chipmunk</code> allows you to work with DLT traces both as standalone files and as part of network captures saved in pcap or pcapng formats. DLT content can also be extracted from SomeIp packets.</p>"},{"location":"#log-collection","title":"Log Collection","text":"<p><code>chipmunk</code> supports the following input sources out of the box:</p> <ul> <li>TCP  </li> <li>UDP  </li> <li>Serial Port  </li> <li>Output from a command or program</li> </ul> <p>For each source, you can assign a parser - for example, to collect DLT packets over a UDP connection for analysis or to save them as a standalone trace file.</p> <p>Another key feature is the ability to launch any command or program and collect its output, which can be analyzed in real time as it's generated.</p>"},{"location":"#search","title":"Search","text":"<p>At its core, <code>chipmunk</code> is a log analysis tool. It goes beyond simple search queries: you can create filter sets, save them, and reuse them across sessions. An intuitive interface allows you to label filters with different colors for more effective analysis.</p> <p></p> <p>The search engine works dynamically - results are updated in real time as new data is added. If you're connected to a live data source, your active filters will continuously update the search results as new logs arrive.</p>"},{"location":"#metrics-measurements-and-graphs","title":"Metrics, Measurements, and Graphs","text":"<p><code>chipmunk</code> includes a graphical tool for log analysis. You can define regular expressions to capture specific metrics and generate real-time charts to visualize their changes over time.</p> <p></p> <p>As with search, the graphical tool updates live as new content is streamed into the application.</p> <p></p>"},{"location":"charts/","title":"Charts","text":"<p>In addition to search, <code>chipmunk</code> provides tools for analyzing metrics and any kind of numerical data. Users can define regular expressions to extract specific values, which are then used to generate charts.</p> <p>A key advantage of <code>chipmunk</code> is its near insensitivity to data volume - it performs equally well when processing a few hundred values or several million.</p>"},{"location":"charts/#chart-creating","title":"Chart creating","text":"<p>To create a chart:</p> <ul> <li>focus in search input</li> <li>enter search condition as regex and group with digits value, for example <code>cpu=(\\d{1,})</code></li> <li>press \"Enter\" to activate the condition</li> <li>click on the chart icon</li> <li>switch to the tab \"Charts\"</li> </ul> <p></p> <p>In tab \"Charts\" also renders a frequency of matches for filters</p>"},{"location":"charts/#dynamic-charts","title":"Dynamic charts","text":"<p>As soon as the chart has been created, Chipmunk updates values and rebuilds the chart withing new values.</p> <p></p>"},{"location":"cli/","title":"Chipmunk CLI Tool","text":"<p>In addition to the powerful GUI application, <code>chipmunk</code> is also available as a CLI tool.</p> <p>Chipmunk CLI is a command-line tool designed to connect to multiple data sources, process incoming data, and write the output to a file in both binary and text formats. It supports:  </p> <ul> <li>Connecting to TCP, UDP sockets, and files as input sources.  </li> <li>Parsing data using various formats.  </li> <li>Writing processed data to binary and text output formats.  </li> <li>Reconnecting to TCP servers when configured.  </li> <li>Providing status updates while running.  </li> </ul> <p>For details on supported parsers and input sources, see the sections below.  </p>"},{"location":"cli/#buildinstallation","title":"Build/Installation","text":""},{"location":"cli/#prerequisites","title":"Prerequisites","text":"<p>Before installing the Chipmunk CLI tool, ensure that Rust is installed on your system. If Rust is not yet installed, follow the official installation instructions for your platform:</p> <ul> <li>Install Rust: Visit rustup.rs and follow the instructions to install Rust.</li> </ul>"},{"location":"cli/#install-chipmunk-cli","title":"Install Chipmunk CLI","text":"<p>Navigate to the root directory of the Chipmunk repository in your terminal and run the following command to install the Chipmunk CLI tool:</p> <pre><code>cargo install --path cli/chipmunk-cli\n</code></pre> <p>This command installs the tool <code>chipmunk-cli</code>, allowing you to use <code>chipmunk-cli &lt;ARGS&gt; &lt;COMMAND&gt;</code> to execute parsing tasks using multiple parsers and input sources.</p>"},{"location":"cli/#usage","title":"Usage","text":"<p>To see available command-line options, run:</p> <pre><code>chipmunk-cli --help\n</code></pre> <pre><code>CLI Tool for parsing bytes form different source supporting multiple data formats\nversion: 0.1.0\n\nUsage: chipmunk-cli [OPTIONS] --output &lt;OUTPUT_PATH&gt; &lt;COMMAND&gt;\n\nCommands:\n  dlt   Establishes a DLT session using the configured parser\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -o, --output &lt;OUTPUT_PATH&gt;\n          Specify the path for the output file\n\n  -f, --output-format &lt;OUTPUT_FORMAT&gt;\n          Specify the format of the output\n\n          [default: binary]\n\n          Possible values:\n          - binary: Output in binary format\n          - text:   Parsed output as text\n\n  -a, --append-output\n          Appends to the output file if it exists, rather than returning an error\n\n      --cols-sep &lt;TEXT_COLUMNS_SEPARATOR&gt;\n          Sets the column separator for parsed data in text output\n\n          [default: \" , \"]\n\n      --args-sep &lt;TEXT_ARGS_SEPARATOR&gt;\n          Sets the argument separator for payload column in text output\n\n          [default: \" ; \"]\n\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n</code></pre> <p>Chipmunk supports configuring and running multiple parsers with various input source in a generic way with multiple level of CLI subcommands. To run a command users need to specify the output options at first alongside with other optional global flags then they need to specify the parser in its configurations as a subcommand, finally they need to specify the input source as final subcommand next to its configurations. Here are some example: Reading data from a TCP server with the address <code>127.0.0.1:7777</code> with reconnecting configured to retry for 1000 times, then parsing data in DLT with multiple FIBEX files and exporting the data in binary format appending to the end of the output file if exists.</p> <pre><code>chipmunk-cli -o ~/Desktop/chip_output/logs.dlt -a -f binary dlt -f ~/Fibex/file1.xml -f ~/Fibex/file1.xml tcp 127.0.0.1:7777 -m 1000\n</code></pre>"},{"location":"cli/#supported-parsers","title":"Supported Parsers:","text":""},{"location":"cli/#dlt-diagnostic-log-and-trace","title":"DLT (Diagnostic Log and Trace)","text":"<p>Chipmunk can parse DLT messages from various sources and export the output in both text and binary formats. It also supports FIBEX metadata files.</p> <pre><code>$ chipmunk-cli dlt --help\nEstablishes a DLT session using the configured parser\n\nUsage: chipmunk-cli --output &lt;OUTPUT_PATH&gt; dlt [OPTIONS] &lt;COMMAND&gt;\n\nCommands:\n  tcp   Establish a TCP connection using the specified IP address as the input source\n  udp   Establish a UDP connection using the specified IP address as the input source\n  file  Read input from a file at the specified path\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -f, --fibex-files &lt;FIBEX_FILES&gt;  The paths to the FIBEX files used for this parsing session\n  -h, --help                       Print help\n</code></pre> <p>When exporting to binary format, Chipmunk automatically generates a default storage header for each message if one is not already present.</p>"},{"location":"cli/#supported-input-sources","title":"Supported Input Sources:","text":""},{"location":"cli/#tcp-socket","title":"TCP Socket","text":"<p>Chipmunk can establish a connection with a TCP server, receive data from it, and parse it. It also supports automatic reconnection if the connection is lost. Reconnection is enabled only when the <code>--max-reconnect</code> option is specified. If not set, the session will terminate as soon as the connection to the server is lost.</p> <p>Additionally, Chipmunk supports keep-alive probes to maintain the connection with the server.  Keep-alive is enabled only when the <code>--keep-alive</code> option is set. It specifies the time interval (in seconds) between keep-alive probes sent to the TCP server.</p> <pre><code>$ chipmunk-cli dlt tcp --help\nEstablish a TCP connection using the specified IP address as the input source\n\nUsage: chipmunk-cli dlt tcp [OPTIONS] &lt;ADDRESS&gt;\n\nArguments:\n  &lt;ADDRESS&gt;  The address to bind the connection to\n\nOptions:\n  -u, --update-interval &lt;UPDATE_INTERVAL&gt;\n          Time interval (in seconds) to print current status [default: 5]\n  -m, --max-reconnect &lt;MAX_RECONNECT_COUNT&gt;\n          Maximum number of reconnection attempts if the connection is lost.\n          Value must be set to enable automatic reconnect to server.\n  -r, --reconnect-interval &lt;RECONNECT_INTERVAL&gt;\n          Time interval (in seconds) between reconnection attempts [default: 1]\n  -k, --keep-alive &lt;KEEP_ALIVE&gt;\n          Time interval (in seconds) to send `keep-alive` probes to TCP server.\n          Value must be set to enable `keep-alive` on the server.\n  -h, --help\n          Print help\n</code></pre>"},{"location":"cli/#udp-socket","title":"UDP Socket:","text":"<p>Chipmunk can receive data from a UDP socket, continuously processing incoming messages from a specified address.  Since UDP is connectionless by design, Chipmunk will automatically handle incoming packets without requiring reconnection logic.</p> <pre><code>$ chipmunk-cli dlt udp --help\nEstablish a UDP connection using the specified IP address as the input source\n\nUsage: chipmunk-cli dlt udp [OPTIONS] &lt;ADDRESS&gt;\n\nArguments:\n  &lt;ADDRESS&gt;  The address to bind the connection to\n\nOptions:\n  -u, --update-interval &lt;UPDATE_INTERVAL&gt;\n          Time interval (in seconds) to print current status [default: 5]\n  -h, --help\n          Print help\n</code></pre>"},{"location":"cli/#file-input","title":"File Input","text":"<p>Chipmunk can read and parse data from a local file, allowing you to process previously captured logs or recorded data. </p> <pre><code>$ chipmunk-cli dlt file --help\nRead input from a file at the specified path\n\nUsage: chipmunk-cli dlt file &lt;PATH&gt;\n\nArguments:\n  &lt;PATH&gt;  Path to the input file\n\nOptions:\n  -h, --help  Print help\n</code></pre>"},{"location":"cli/#examples","title":"Examples","text":"<p>Chipmunk provides a flexible way to configure and run multiple parsers with various input sources using a structured CLI format with multiple levels of subcommands.  </p> <p>To execute a command, users first specify output options along with any global flags. Next, they define the parser and its configurations as a subcommand. Finally, they specify the input source and its settings as the last subcommand.  </p>"},{"location":"cli/#binary-dlt-on-tcp","title":"Binary DLT on TCP","text":"<p>Reads data from a TCP server at <code>127.0.0.1:7777</code>, enabling automatic reconnection with up to 1000 retries. The data is parsed using the DLT format with multiple FIBEX files and exported in binary format, appending to the output file if it already exists.  </p> <pre><code>chipmunk-cli -o ~/Output/logs.dlt -a -f binary dlt -f ~/Fibex/file1.xml -f ~/Fibex/file2.xml tcp 127.0.0.1:7777 -m 1000\n</code></pre>"},{"location":"cli/#text-dlt-from-binary-file","title":"Text DLT from Binary File","text":"<p>Reads DLT binary data from a local file, parses it into text, and formats the output using the default separators for columns and payload arguments.  </p> <pre><code>chipmunk-cli -o ~/Output/logs.log -f text dlt file ~/DLT/file.dlt\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p><code>chipmunk</code> is distributed as a portable version and does not require any installation - just download and run. Additionally:</p> <ul> <li>It does not install or depend on any external libraries or runtime environments (with a small exception for Windows).</li> <li>It includes a built-in update mechanism (you will be notified when a new version is available).</li> <li>It is available for Linux, Windows, and macOS platforms.</li> </ul>"},{"location":"installation/#download","title":"Download","text":"<p>The latest chipmunk release can be downloaded here.</p>"},{"location":"installation/#mac-os","title":"Mac OS","text":"<p>Move <code>chipmunk.app</code> to your application folder.</p> <p>Or using Homebrew</p> <pre><code>brew install --cask chipmunk\n</code></pre>"},{"location":"installation/#windows","title":"Windows","text":"<p>Unpack chipmunk to a folder of your choosing. Use the <code>chipmunk.exe</code> to start chipmunk.</p> <p>Requirements: - should be installed a latest package of Microsoft Visual C++ Redistributable</p>"},{"location":"installation/#linux","title":"Linux","text":"<p>Unpack chipmunk to a folder of your choosing. Use the <code>chipmunk</code> executable to start chipmunk. </p> <p>Additionally, each <code>chipmunk</code> release comes with <code>deb</code> and <code>rpm</code> packages.</p>"},{"location":"navigation/","title":"Navigation","text":"<p>We\u2019ve put a lot of effort into making the <code>chipmunk</code> interface simple and intuitive, despite the complexity of the tasks it performs. Based on the feedback we\u2019ve received from users, we placed special emphasis on speed and ease of access to log file locations, as well as quick access to recent user activity.</p>"},{"location":"navigation/#quick-navigation","title":"Quick navigation","text":"<p>To have quick access to places, where log files are stored, folder(s) can be added into favorites. On Chipmunk's home screen, all files from the favorites folder(s) will be listed with the possibility to filter them by name.</p> <p></p> <p>In addition to home screen favorites are also available with <code>Ctrl + P</code> (<code>Command + P</code>). In this case file(s) from favorite places are mixed with recent actions.</p>"},{"location":"navigation/#recent-activities","title":"Recent activities","text":"<p>Chipmunk tracks not only recently opened files but also recently created streams. </p> <p>The main list of recent actions is present on Chipmunk's home screen. But it is also available with <code>Ctrl + P</code> (<code>Command + P</code>). In this case, a recent actions list is mixed with file(s) from favorite places.</p> <p></p>"},{"location":"search/","title":"Search","text":"<p>At the heart of <code>chipmunk</code> lies its powerful search functionality. <code>chipmunk</code> allows you to create sets of diverse search conditions (called filters), combine them, save them, and apply them as needed for different scenarios.</p>"},{"location":"search/#creating-of-filter","title":"Creating of filter","text":"<p>To create a filter:</p> <ul> <li>focus in search input</li> <li>enter the search condition</li> <li>press \"Enter\" to activate the search</li> <li>press \"Enter\" once again or click on the filter icon</li> </ul> <p>As a result, the filter will be saved in a list of filters. Chipmunk supports any number of filters/charts, but the performance of a search depends on the number of filters/charts.</p> <p></p>"},{"location":"search/#active-search","title":"Active search","text":"<p>If some value is present in the search input - it's an active search and search results are present only for this filter.</p> <p>Any saved filter can be quickly converted to active search via: - context menu \"Show matches\" - double-click on the filter in a list</p> <p></p>"},{"location":"search/#managing-filters","title":"Managing filters","text":"<p>Checked/Unchecked/Disabled filters</p> <ul> <li>Cheked filer will be used to make a search and matches will be shown in a search results view.</li> <li>Unchecked filters will not be used to make a search, but colors still be applied and rows with matches will be highlighted in the main view.</li> <li>Disabled filter will not be considered in the search and will not be highlighted. Disabling filters are useful to turn off some filter completely but still have a way to quickly restore it</li> </ul> <p></p>"},{"location":"search/#importing-exporting","title":"Importing / Exporting","text":"<p>Filters/charts will be associated with an opened file (or stream). Next time the same file (or stream) is opened, filters/charts will be restored.</p> <p>At the same time, there are a couple of ways to export/import filters:</p> <ul> <li>via the context menu on the list of filters/charts</li> <li>via tab \"History/Profiles\" to export/import different collections of filters/charts</li> </ul> <p></p>"},{"location":"search/#breadcrumbs","title":"Breadcrumbs","text":"<p>Breadcrumbs mode allows mixed search results and other content. It's very useful in cases when it's essential to understand what was logged before/after the target occasion.</p> <p></p>"},{"location":"teamwork/","title":"Teamwork","text":"<p><code>chipmunk</code> supports collaborative work on log file analysis. However, it remains a fully standalone application that requires no installation or server infrastructure. Staying true to this philosophy, we use GitHub repositories to enable shared access to data - providing both secure data exchange and access control.</p>"},{"location":"teamwork/#before-start","title":"Before start","text":""},{"location":"teamwork/#using-github-repositories","title":"Using GitHub repositories","text":"<p>To share a session's data chipmunk uses GitHub repositories. With each change of the session's data, chipmunk makes commits with the latest state of the session and this data becomes available for other users, who are also \"connected\" to the same repository.</p>"},{"location":"teamwork/#add-new-repository","title":"Add new repository","text":"<p>To allow sharing of the session's data should be defined a GitHub repository, which will be used as a storage of a session's data. </p> <ul> <li>switch to tab \"TEAMWORK\" on  a sidebar;</li> <li>press the menu button \"...\" and select \"Add New GitHub Reference\"</li> <li>define necessary fields and press \"Save\"</li> </ul> <p>You can add multiple references to repositories and switch between it during work.</p>"},{"location":"teamwork/#github-personal-token","title":"GitHub Personal Token","text":"<p>GitHub REST API requires authorization. To use the teamwork feature you should create a personal token. You have two options:</p> <ul> <li>Read-only mode. Personal token without any writing rights. With this type of token, you will be able to pull a session's data from the GitHub repository, but will not be able to change it.</li> <li>Standard. Personal token with write rights. With this type of token, any change of any session's data (filters, charts, comments, etc) will be synchronized with a GitHub repository and become available for other users.</li> </ul> <p>Note. Chipmunk uses your GitHub personal token only to communicate with the target repository. In read-only mode, chipmunk makes REST API requests to pull data from a repository. In standard mode, in addition, chipmunk makes commits to the target repository with changes of session's data.</p> <p>To create the GitHub personal token:</p> <ul> <li>open your GitHub page</li> <li>go to \"Settings\" of your account (not the settings of a repository)</li> <li>go to section \"Developer Settings\" (very bottom of left sidebar)</li> <li>open the scroll \"Personal Access Tokens\" and select a type of token, which you would like to create. Chipmunk works with both.</li> </ul>"},{"location":"teamwork/#share-your-findings","title":"Share your findings","text":"<p>With the teamwork feature, you are able to share between multiple users the session's data like:</p> <ul> <li>filters;</li> <li>charts;</li> <li>bookmarks;</li> <li>comments;</li> </ul> <p>Note. The teamwork feature is available only for files. You cannot share information for any kind of stream (network connections, spawned terminal command, etc).</p>"},{"location":"teamwork/#modes","title":"Modes","text":"<p>The teamwork feature supports two modes:</p> <ul> <li> <p>Read-only mode. You will be able to pull a session's data from the GitHub repository, but will not be able to change it.</p> </li> <li> <p>Standard. With this type of token, any change of any session's data (filters, charts, comments, etc) will be synchronized with a GitHub repository and become available for other users.</p> </li> </ul>"},{"location":"teamwork/#data-to-share","title":"Data to share","text":"<p>You can define, which data will be shared and synchronized. For example, you can keep synchronized only comments, but use your local filters/charts and bookmarks.</p> <p>To define these rules: </p> <ul> <li>switch to the tab \"TEAMWORK\" in the sidebar;</li> <li>open a scroll \"Sharing Settings\";</li> <li>select type of data, which you would like to share</li> </ul>"},{"location":"contributing/debugging/","title":"Debugging","text":"<p>This guide covers debugging the Chipmunk application, including logs and component-specific procedures</p>"},{"location":"contributing/debugging/#debugging-procedures","title":"Debugging Procedures","text":""},{"location":"contributing/debugging/#frontend-components","title":"Frontend Components","text":"<p>The Chipmunk frontend consists of multiple components, each with a different debugging method.</p>"},{"location":"contributing/debugging/#debugging-electron-app","title":"Debugging Electron App","text":"<p>To debug the Electron <code>holder</code> application, located at <code>{CHIPMUNK_ROOT}/application/holder</code>, a debug session can be invoked directly from VS Code or any debugger that supports its launch configurations.</p> <p>A standard launch configuration object must be added to your debugger's settings. This configuration should point to the Electron executable and the application's entry point.</p> <pre><code>{\n  \"type\": \"node\",\n  \"request\": \"launch\",\n  \"name\": \"Debug Electron\",\n  \"runtimeExecutable\": \"${workspaceRoot}/application/holder/node_modules/.bin/electron\",\n  \"program\": \"${workspaceRoot}/application/holder/src/app.ts\",\n  \"outFiles\": [\"${workspaceRoot}/application/holder/dist/**/*.js\"]\n}\n</code></pre> <p>Before starting each debug session, you must build the application with the development CLI tool via:</p> <pre><code>cargo chipmunk build app\n</code></pre>"},{"location":"contributing/debugging/#debugging-client","title":"Debugging Client","text":"<p>The application <code>client</code>, located at <code>{CHIPMUNK_ROOT}/application/client</code>, is a standard web application that you can debug using the built-in Chromium Developer Tools.</p> <p>1. Opening Developer Tools</p> <p>You can open the developer tools in several ways:</p> <ul> <li>Menu: Select <code>Chipmunk</code> -&gt; <code>Developing</code> -&gt; <code>Toggle Developer Tools</code>.</li> <li>Shortcut: Press Ctrl + Shift + I.</li> <li>Environment Variable: Set <code>CHIPMUNK_DEVELOPING_MODE=true</code> before launching the application.</li> </ul> <p>2. Using the Debugger</p> <p>Once the developer tools are open, you can: * Inspect <code>console.log()</code> output in the Console tab. * Set breakpoints in the source code under the Sources tab, located at <code>webpack:///./src/</code>.</p>"},{"location":"contributing/debugging/#debugging-communication-libraries","title":"Debugging Communication Libraries","text":"<p>Chipmunk uses several shared libraries to facilitate communication between the Rust backend and the frontend components.</p> <p>You can debug these libraries using the same VS Code workflow as the Electron <code>holder</code>. However, because these libraries are copied into the <code>holder</code>'s <code>node_modules</code> directory during the build process, you'll need to use the specific debug paths listed below.</p> <ul> <li><code>platform</code>: Provides shared type definitions for frontend projects. Debug at <code>{CHIPMUNK_ROOT}/application/holder/node_modules/platform</code>.</li> <li><code>ts-bindings</code>: Includes type definitions for Rust-to-Electron communication. Debug at <code>{CHIPMUNK_ROOT}/application/holder/node_modules/rustcore/ts-bindings</code>.</li> </ul>"},{"location":"contributing/debugging/#rust-backend","title":"Rust Backend","text":"<p>The recommended methods for debugging the Rust backend are print-based debugging and structured logging.</p> <p>You can use Rust's standard printing macros for immediate feedback during development. For more persistent and configurable diagnostics, the backend uses a logging framework, which is the primary method for monitoring the application's behavior.</p> <p>The configuration for this logging system is detailed in the next section.</p>"},{"location":"contributing/debugging/#logs-and-configuration-files","title":"Logs and Configuration Files","text":"<p>Checking the log output is the first step in diagnosing most issues. Chipmunk's log files and their configurations are located within the Chipmunk home directory.</p>"},{"location":"contributing/debugging/#log-files","title":"Log Files","text":"<ul> <li><code>chipmunk.log</code>: Logs for the Chipmunk Electron frontend.</li> <li><code>chipmunk.indexer.log</code>: Logs for the Chipmunk Rust backend (indexer).</li> <li><code>chipmunk.updater.log</code>: Logs for the Chipmunk updater binary.</li> <li><code>chipmunk.launcher.log</code>: Logs for the application during backend initialization.</li> </ul>"},{"location":"contributing/debugging/#configuration-files","title":"Configuration Files","text":"<p>Backend logging is configured using the log4rs crate. To adjust log levels or other settings, modify the relevant YAML files.</p> <ul> <li><code>log4rs.yaml</code>: Configuration for the Rust backend. (Note: The first line of this file is used for version control and should not be changed.)</li> <li><code>log4rs_updater.yaml</code>: Configuration for the updater tool.</li> </ul>"},{"location":"contributing/dev-cli/","title":"Developer CLI Tool","text":""},{"location":"contributing/dev-cli/#chipmunk-development-cli-tool","title":"Chipmunk Development CLI Tool","text":"<p>This CLI Tool provides an easier way to manage various development tasks for Chipmunk. Chipmunk consists of multiple modules with complex dependencies on each other, and this tool helps streamline the development process by coordinating these tasks seamlessly. This tool acts as a cargo extension. Once installed, you can access it by running <code>cargo chipmunk &lt;COMMAND&gt; &lt;ARGS&gt;</code> from anywhere within the repository.</p>"},{"location":"contributing/dev-cli/#buildinstallation","title":"Build/Installation","text":""},{"location":"contributing/dev-cli/#prerequisites","title":"Prerequisites","text":"<p>Before installing the Chipmunk CLI tool, ensure that Rust is installed on your system. If Rust is not yet installed, follow the official installation instructions for your platform:</p> <ul> <li>Install Rust: Visit rustup.rs and follow the instructions to install Rust.</li> </ul>"},{"location":"contributing/dev-cli/#install-chipmunk-development-cli","title":"Install Chipmunk Development CLI","text":"<p>Navigate to the root directory of the Chipmunk repository in your terminal and run the following command to install the Chipmunk Development CLI tool:</p> <pre><code>cargo install --path cli/development-cli\n</code></pre> <p>This command installs this tool as a cargo extension, allowing you to use <code>cargo chipmunk &lt;COMMAND&gt; &lt;ARGS&gt;</code> to execute various development tasks for Chipmunk.</p>"},{"location":"contributing/dev-cli/#usage","title":"Usage","text":"<p>This CLI tool provides multiple sub-commands for different tasks, with each sub-command offering various arguments.</p>"},{"location":"contributing/dev-cli/#general-commands-overview","title":"General Commands Overview","text":"<pre><code>CLI Tool for chipmunk application development\n\nUsage: cargo chipmunk &lt;COMMAND&gt;\n\nCommands:\n  environment       Provides commands for the needed tools for the development [aliases: env]\n  print-dot         Prints an overview of targets dependencies in print-dot format for `Graphviz` [aliases: dot]\n  configuration     Provides commands for the configuration of this tool on user level [aliases: config]\n  lint              Runs linting &amp; clippy for all or the specified targets\n  build             Build all or the specified targets\n  clean             Clean all or the specified targets\n  test              Run tests for all or the specified targets\n  run               Build and Run the application\n  release           Builds Chipmunk and generates a release (defaults to Release mode)\n  benchmark         Runs benchmarks for the given target, its input source and configuration [aliases: bench]\n  reset-records     Resets the build states records what is used to check if there were any changes for each target [aliases: reset]\n  shell-completion  Generate shell completion for the commands of this tool in the given shell, printing them to stdout [aliases: compl]\n  help              Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n</code></pre>"},{"location":"contributing/dev-cli/#build-command","title":"Build Command","text":"<pre><code>Usage: cargo chipmunk build [OPTIONS] [TARGET]...\n\nArguments:\n  [TARGET]...\n          Target to build, by default whole application will be built\n\n          Possible values:\n          - core:         Represents the path `application/apps/indexer`\n          - shared:       Represents the path `application/platform`\n          - protocol:     Represents the path `application/apps/protocol`\n          - binding:      Represents the path `application/apps/rustcore/rs-bindings`\n          - wrapper:      Represents the path `application/apps/rustcore/ts-bindings`\n          - wasm:         Represents the path `application/apps/rustcore/wasm-bindings`\n          - client:       Represents the path `application/client`\n          - updater:      Represents the path `application/apps/precompiled/updater`\n          - app:          Represents the path `application/holder`\n          - cli-dev:      Represents the path `cli/development-cli`\n          - cli-chipmunk: Represents the path `cli/chipmunk-cli`\n\nOptions:\n  -p, --production\n          Build release version\n\n  -f, --fail-fast\n          Stops execution immediately if any job fails.\n\n  -u, --ui-mode &lt;UI_MODE&gt;\n          Specifies the UI options for displaying command logs and progress in the terminal\n\n          Possible values:\n          - bars:      Displays progress bars, showing the current line of the output of each command. [aliases: 'b']\n          - report:    Displays progress bars and prints a summary of all command logs to stdout after all jobs have finished. [aliases: 'r']\n          - print:     Outputs each job's result to stdout once the job finishes. No progress bars are displayed. [aliases: 'p']\n          - immediate: Outputs logs immediately as they are produced, which may cause overlapping logs for parallel jobs. No progress bars are displayed. [aliases: 'i']\n\n  -s, --skip-env-checks\n          Skip development environment checks.\n\n  -a, --additional-features &lt;ADDITIONAL_FEATURES&gt;\n          Specifies additional features to be enabled in the build process\n\n          Possible values:\n          - custom-alloc: Activate `custom-alloc` feature in rs-binding to use custom memory allocator instead of the default one.\n\n  -h, --help\n          Print help (see a summary with '-h')\n</code></pre>"},{"location":"contributing/dev-cli/#user-configurations","title":"User Configurations","text":"<p>Users can configure their preferences for the shell used to run process commands and the default UI mode. The configuration file should be located in the Chipmunk home directory, within the <code>build_cli</code> directory, named <code>config.toml</code>.</p> <p>Configurations can be managed via the CLI using the <code>config</code> subcommands. These subcommands allow you to resolve the path to the configuration file and generate default configurations, with an option to write them directly to the file.</p> <p>Below is an example of the configuration file with the available settings:</p> <pre><code># Defines the shell to be used for executing process commands.\n# Options:\n#   - `sh` (Unix-based systems only)\n#   - `cmd` (Windows only)\n#   - `bash`\n#   - `zsh`\n#   - `fish`\n#   - `nu-shell`\n#   - `elvish`\n#   - `power-shell`\n# If not specified, the system will default to:\n#   - The value of the `SHELL` environment variable on Unix-based systems.\n#   - `cmd` on Windows.\nshell = \"sh\"\n\n# Defines the preferred UI mode.\n# Options:\n#   - `bars`: Displays progress bars, showing the current line of the output of each command.\n#   - `report`: Displays progress bars and prints a summary of all command logs to stdout after all jobs have finished.\n#   - `print`: Outputs each job's result to stdout once the job finishes. No progress bars are displayed.\n#   - `immediate`: Outputs logs immediately as they are produced, which may cause overlapping logs for parallel jobs. No progress bars are displayed.\nui_mode = \"bars\"\n\n# Skip environment checks before running development commands.\nskip_env_checks = false\n\n# Specifies additional features to enable during the build process.\n# Options:\n#  - \"custom-alloc\": Activate `custom-alloc` feature in rs-binding to use custom memory allocator instead of the default one.\nadditional_features = []\n</code></pre>"},{"location":"contributing/dev-cli/#benchmarks-via-build-cli-tool","title":"Benchmarks via Build CLI Tool","text":"<p>You can run benchmarks of the Rust Core part directly using the Build CLI tool. Some benchmarks require input sources and additional configurations, which should be provided via environment variables.</p> <p>The CLI tool simplifies running these benchmarks from anywhere in the Chipmunk repository. You can provide the input sources and configurations as CLI arguments, and the tool will handle setting the environment variables for the benchmarks. For more details, use the help command: <code>cargo chipmunk bench --help</code>.</p> <p>The registered benchmarks are loaded from <code>chipmunk/cli/development-cli/config/bench_core.toml</code>. To add a new benchmark, please include it in this configuration file.</p>"},{"location":"contributing/dev-cli/#shell-completion","title":"Shell Completion","text":"<p>The Chipmunk CLI tool supports shell completion for various shells. You can generate shell completions and print them to <code>stdout</code> using the following command:</p> <pre><code>cargo chipmunk shell-completion &lt;SHELL&gt;\n</code></pre> <p>Replace <code>&lt;SHELL&gt;</code> with the name of your shell (e.g., bash, zsh, fish, powershell).</p> <p>To use shell completion, you can redirect the output of the completion command to a file and save the file to the appropriate shell completion directory.</p> <p>After installing the completion script, restart your shell session or source the completion file to enable shell completion for the Chipmunk CLI tool.</p>"},{"location":"contributing/dev-cli/#example-bash-shell","title":"Example: Bash Shell","text":"<p>To enable bash shell completion, run the following command to generate the completion script and save it to a file:</p> <pre><code>cargo chipmunk shell-completion bash &gt; chipmunk-completion.bash\n</code></pre> <p>Next, copy the chipmunk-completion.bash file to your bash completion directory (typically  ~/.bash_completion.d/ or /etc/bash_completion.d/).</p>"},{"location":"contributing/dev-cli/#changelogs","title":"Changelogs:","text":"<p>Changelogs can be found here</p>"},{"location":"contributing/dev-cli/#contributing","title":"Contributing","text":"<p>Contributions in any part of Chipmunk are very welcome!</p> <p>After making any changes to this build CLI tool, please run the integration tests to ensure that all the provided commands in this tool are still working as expected. Additionally, consider adding new tests when introducing new features and commands.</p> <p>To run all the tests, execute the Python file <code>chipmunk/cli/development-cli/integration_tests/run_all.py</code> from within the <code>chipmunk/cli/development</code> directory. For example:</p> <pre><code># Move to cli directory\ncd cli\n# Run python file\npython ./integration_tests/run_all.py\n</code></pre> <p>Please be aware that these tests will run on your local copy of Chipmunk. This process will rebuild the project and run all linting and tests on the entire solution.</p>"},{"location":"contributing/development-guide/","title":"Development Guide","text":""},{"location":"contributing/development-guide/#development-workflow","title":"Development Workflow","text":"<p>Chipmunk consists of a Rust backend for log processing, an Electron/Angular frontend application, and smaller libraries facilitating communication between them. Development tasks across these different components are managed using the Chipmunk Development CLI Tool.</p> <p>This tool simplifies common operations such as building, linting, and running various parts of Chipmunk. It automatically handles project dependencies and tracks changes in source files, ensuring that only necessary components are rebuilt. For comprehensive details on all available commands and functionalities, please consult the documentation for the development CLI tool.</p>"},{"location":"contributing/development-guide/#building-the-application","title":"Building the Application","text":"<p>Use the development CLI tool to build the Chipmunk application:</p> <pre><code># For development build\ncargo chipmunk build app\n\n# For production build\ncargo chipmunk build app -p\n</code></pre> <p>These commands automatically determine and build only the components that have changed since the last build, optimizing build times.</p>"},{"location":"contributing/development-guide/#running-the-application","title":"Running the Application","text":"<p>You can similarly use the run command to start the Chipmunk application:</p> <pre><code># Run in development\ncargo chipmunk run\n\n# Run in production\ncargo chipmunk run -p\n</code></pre> <p>The run command automatically performs any necessary builds of modified components before launching the application interface.</p>"},{"location":"contributing/development-guide/#development-cli-help","title":"Development CLI Help","text":"<p>To explore the full range of commands and options available with the <code>cargo chipmunk</code> development tool, use the <code>--help</code> flag:</p> <p>To list all top-level commands:</p> <pre><code>cargo chipmunk --help\n</code></pre> <p>To view options for a specific command (for example, the <code>build</code> command):</p> <pre><code>cargo chipmunk build --help\n</code></pre>"},{"location":"contributing/development-guide/#code-quality-checks","title":"Code Quality Checks","text":"<p>Before submitting a Pull Request (PR), please run the linters and tests using the development CLI tool. This helps ensure your changes follow the project's coding style and pass basic automated checks.</p> <p>To check for formatting issues, code smells, or potential errors, run the linters:</p> <p>Run linters for the entire project:</p> <pre><code>cargo chipmunk lint\n</code></pre> <p>To run linting for the backend only you can use</p> <pre><code>cargo chipmunk lint core binding\n</code></pre> <p>To run linting for the frontend only you can use</p> <pre><code>cargo chipmunk lint shared wrapper client app\n</code></pre> <p>Ensure your changes are covered by appropriate test cases. Run all test cases to verify that everything is working as expected:</p> <pre><code>cargo chipmunk test\n</code></pre>"},{"location":"contributing/development-guide/#reporting-issues","title":"Reporting Issues","text":"<p>Your contributions through bug reports and suggestions are greatly appreciated!</p> <p>If you discover any bugs, have suggestions for improvements, or identify potential issues within Chipmunk, please report them by opening a new issue on the project's GitHub repository. When reporting bugs, providing a clear description and steps to reproduce the issue is very helpful.</p>"},{"location":"contributing/getting-started/","title":"Getting Started","text":"<p>This guide covers the one-time setup required to install all the tools and dependencies you need to build and run Chipmunk.</p>"},{"location":"contributing/getting-started/#prerequisites","title":"Prerequisites","text":""},{"location":"contributing/getting-started/#installing-rust","title":"Installing Rust","text":"<p>To install Rust, follow the official instructions provided on the Rust programming language website. This ensures you are using the recommended method for your specific operating system.</p> <p>You can find the installation guide at Install Rust</p>"},{"location":"contributing/getting-started/#installing-nodejs","title":"Installing NodeJS","text":"<p>We recommend using NVM (Node Version Manager) to install and manage Node.js versions. Please follow the NVM installation guide first.</p> <p>Once NVM is installed and configured, you can install the latest Long Term Support (LTS) version of Node.js by running:</p> <pre><code>nvm install --lts\n</code></pre> <p>Verify that Node.js is installed correctly by running:</p> <pre><code>node -v\n</code></pre> <p>This will print the installed Node.js version in your terminal.</p>"},{"location":"contributing/getting-started/#installing-yarn","title":"Installing Yarn","text":"<p>Chipmunk uses Yarn for managing frontend dependencies. While the project specifies a particular Yarn version via Corepack, our current setup still checks for a global Yarn installation.</p> <p>First, install Yarn globally using <code>npm</code>:</p> <pre><code>npm install -g yarn\n</code></pre> <p>Additionally, this project enforces a required Yarn version specified in its <code>package.json</code> file to ensure consistent dependency management across all development environments. To automatically use this project-defined version, you need to enable Corepack:</p> <pre><code>corepack enable\n</code></pre> <p>Enabling Corepack ensures that when you run <code>yarn</code> commands within the Chipmunk project directory, NodeJS will automatically use the version specified by the project, even if a different version is installed globally.</p>"},{"location":"contributing/getting-started/#installing-project-dependencies","title":"Installing Project Dependencies","text":"<p>This project relies on external dependencies for both the Rust backend and the Electron/Node.js frontend. To install all necessary project dependencies and tools, run the following script from the repository root:</p> <pre><code>sh developing/scripts/install.sh\n</code></pre> <p>This script will handle installing dependencies required for building and running Chipmunk.</p>"},{"location":"contributing/getting-started/#installing-the-development-cli","title":"Installing the Development CLI","text":"<p>This project uses a custom tool, <code>cargo chipmunk</code>, to manage development tasks. To install it, navigate to the repository root and run:</p> <pre><code>cargo install --path cli/development-cli\n</code></pre> <p>After installation, verify it was successful by checking the version:</p> <pre><code>cargo chipmunk --version\n</code></pre> <p>For a complete list of commands, please refer to the dedicated CLI documentation.</p>"},{"location":"contributing/getting-started/#verify-your-setup","title":"Verify Your Setup","text":"<p>To confirm that the development environment and all dependencies are correctly installed, run the following command. It will check your setup and print a list of all required tools and their detected versions.</p> <pre><code>cargo chipmunk env list\n</code></pre> <p>If the command runs without errors and you see the list of versions, your setup is complete!</p>"},{"location":"contributing/getting-started/#next-steps","title":"Next Steps","text":"<p>To learn about the daily workflow for building, running, and testing the application, please proceed to the next guide: Development Guide</p>"},{"location":"contributing/welcome/","title":"Contributing to Chipmunk","text":"<p>Thank you for your interest in contributing to Chipmunk! This document provides a guide to setting up your development environment and making contributions. Chipmunk is developed using Rust for the backend processing and ElectronJS for the frontend application.</p>"},{"location":"contributing/welcome/#where-to-start","title":"Where to Start","text":"<p>To make the process as smooth as possible, we've split the documentation into several key areas. If you are a new contributor, we recommend reading them in order.</p> <ul> <li> <p>1. Getting Started Your first stop. This guide walks you through installing all the necessary tools and dependencies to set up your local development environment.</p> </li> <li> <p>2. Development Guide Once you're set up, this guide covers the daily workflow. Learn how to build, run, test, and lint the application. It also explains our process for submitting a pull request.</p> </li> <li> <p>3. Debugging If you run into issues or need to understand what's happening under the hood, this guide provides information on log files, configurations, and common troubleshooting steps.</p> </li> </ul>"},{"location":"development/core/core/","title":"Chipmunk Core Documentation:","text":"<p>This document serves as a comprehensive guide to the code architecture of the Chipmunk Core. It is intended for developers who wish to understand how Chipmunk processes log data, the relationships between its main components, and how to contribute to its development. Below you will find links to detailed documentation for key architectural areas within the core.</p> <ul> <li>Producer</li> <li>Plugins</li> </ul>"},{"location":"development/core/plugins/","title":"Plugins in Chipmunk Host:","text":"<p>The Chipmunk core supports plugins built with WebAssembly and the Component Model, utilizing the <code>wasmtime</code> runtime for compiling and loading plugin binaries.</p> <p>For a visual representation of the plugins and how they are connected within the data ingestion pipeline, please refer to the diagram.</p>"},{"location":"development/core/plugins/#plugins-runtime","title":"Plugins Runtime","text":"<p>Chipmunk utilizes a single <code>wasmtime</code> runtime engine that is shared by all loaded plugins and the core plugin management logic. This design aligns with the recommended usage pattern for <code>wasmtime</code>.</p> <p>This shared runtime is very reliable. If a plugin crashes or has an error (panics), it won't crash the main runtime or stop other plugins or tasks that are running.</p>"},{"location":"development/core/plugins/#plugins-manager","title":"Plugins Manager","text":"<p>The <code>PluginsManager</code> is a central component responsible for the life cycle of all available plugins. Its duties include scanning, loading, validating, and managing the metadata and configuration of plugins. It also provides functionality for adding and removing plugins without requiring manual file operations by the user.</p> <p>On startup, the <code>PluginsManager</code> scans the designated plugins directory (<code>&lt;HOME&gt;/.chipmunk/plugins</code>). It attempts to load and validate the WebAssembly binaries found there and extract essential information like versions and configuration schemas directly from the binaries' metadata.</p> <p>To optimize startup performance, the <code>PluginsManager</code> employs a caching mechanism. After the initial scan, extracted plugin metadata, configurations, and a hash of the binary are saved to a cache file (located within the plugins directory). On subsequent runs, unchanged plugins are loaded directly from this cache, avoiding the need to recompile and re-extract their information from the binary. The cache can typically be invalidated or reloaded via a UI action.</p> <p>The <code>PluginsManager</code> keeps track of all loaded plugins, their current state, and configurations, making them available to the rest of the Chipmunk application, such as providing loaded plugins to the <code>UnboundSession</code> view in the UI.</p>"},{"location":"development/core/plugins/#plugin-hosts-parser-and-byte-source","title":"Plugin Hosts (Parser and Byte-Source)","text":"<p>For each activated plugin instance (Parser or Byte-Source), a corresponding host-side \"Plugin Host\" struct is created. These host structs act as wrappers, encapsulating all communication with the Wasm plugin binary and managing aspects specific to that plugin type and its API version.</p>"},{"location":"development/core/plugins/#parser-plugin-host","title":"Parser Plugin Host","text":"<p>The Parser Plugin Host specifically manages interactions with a Wasm Parser plugin. It internally handles communication across the Wasm boundary and translates between the plugin's version-specific data types (defined by the WIT contract for that API version) and the general data types used throughout Chipmunk. It encapsulates support for different API versions, potentially by containing version-specific bindings or logic. This host is responsible for loading and validating its specific plugin binary instance and implementing the host functions (like logging, temporary directory access) that the Wasm plugin may call. It delivers the parsed items received from the plugin according to the <code>Parser</code> trait contract used within Chipmunk.</p>"},{"location":"development/core/plugins/#byte-source-plugin-host","title":"Byte-Source Plugin Host","text":"<p>Similar to the Parser Plugin Host, the Byte-Source Plugin Host encapsulates communication and version management for a Wasm Byte-Source plugin. Its implementation, however, leverages Chipmunk's internal <code>BinaryByteSource</code> helper struct.</p> <p>The host-side Byte-Source Plugin struct implements the standard Rust <code>Read</code> trait. This implementation is responsible for communicating with the Wasm plugin binary to poll and retrieve chunks of raw bytes whenever the host needs more data.</p> <p>Chipmunk provides a generic struct, <code>BinaryByteSource</code>, which is designed to wrap any type that implements the <code>std::io::Read</code> trait. The Byte-Source Plugin Host utilizes <code>BinaryByteSource</code>, wrapping its own <code>Read</code> implementation within it. This allows <code>BinaryByteSource</code> to provide the full implementation of the <code>ByteSource</code> trait automatically, handling complexities like offset management and stream positioning.</p> <p>This design ensures that the plugin developer's responsibility is focused on delivering raw bytes when requested via the WASM API (translated to the host's <code>Read</code> calls), while the host-side <code>BinaryByteSource</code> manages the lower-level details of byte-source behavior and stream management.</p>"},{"location":"development/core/plugins/#async-runtime-integration","title":"Async Runtime Integration","text":"<p><code>Wasmtime</code> needs a system to handle async tasks when talking to plugins, even in sync environment it will spawn its own tokio runtime and block on it. Chipmunk already uses <code>Tokio</code> for its own async tasks. By turning on a setting in our <code>wasmtime</code> code, we tell it to use Chipmunk's <code>Tokio</code> system instead of starting its own separate one. This helps things run smoothly and keeps all async tasks working together efficiently.</p>"},{"location":"development/core/producer/","title":"Message Producer","text":"<p>The <code>MessageProducer</code> struct serves as a key component within the Chipmunk core, responsible for orchestrating the data ingestion pipeline. Its primary role is to connect a source providing raw bytes (implementing the <code>ByteSource</code> trait) with a mechanism for interpreting those bytes (implementing the <code>Parser</code> trait), managing the entire cycle from polling data to parsing it and delivering the results for further processing within Chipmunk.</p> <p>The <code>MessageProducer</code> is designed to be generic over different implementations of the <code>ByteSource</code> and <code>Parser</code> traits, allowing for flexible combinations of data sources and parsing formats based on specific session requirements.</p> <p>Implementations for <code>ByteSource</code> and <code>Parser</code> can be either built-in components provided by the Chipmunk core or provided dynamically via the plugin system based on WebAssembly and the Component Model.</p> <p>Chipmunk currently includes the following built-in parsers:</p> <ul> <li>DLT</li> <li>SomeIP</li> <li>StringTokenizer</li> </ul> <p>And a variety of built-in byte-sources:</p> <ul> <li>BinaryByteSource (For files with binary format)</li> <li>TCP</li> <li>UDP</li> <li>Process Commands</li> <li>PCapNG</li> <li>PCap Legacy</li> </ul> <p>For a visual representation of how the Message Producer connects Byte Sources and Parsers, please refer to the diagram.</p>"},{"location":"plugins/c-cpp/","title":"Plugins Development in C/C++","text":"<p>Chipmunk's plugin system, built on WebAssembly and the Component Model, supports developing plugins using C/C++. This document will help you get started with C/C++ plugin development.</p>"},{"location":"plugins/c-cpp/#prerequisites","title":"Prerequisites","text":"<p>Developing plugins in C/C++ requires having the following tools and SDKs on the developer's machine:</p>"},{"location":"plugins/c-cpp/#wit-bindgen","title":"wit-bindgen","text":"<p>The wit-bindgen CLI tool generates C/C++ types and function declarations from WASM Interface Format (WIT) files.  Although the pre-generated C header is included in the C/C++ templates, <code>wit-bindgen</code> is still necessary to generate <code>parse.c</code> and <code>parse_component_type.o</code> files. This process also regenerates the pre-generated the header file.</p>"},{"location":"plugins/c-cpp/#chipmunk-plugins-wit-definitions","title":"Chipmunk Plugins WIT Definitions","text":"<p>To generate the specific C/C++ functions and types that interface with Chipmunk, developers need to have the Chipmunk plugins WIT files available locally on their machines.</p>"},{"location":"plugins/c-cpp/#wasi-sdk","title":"WASI SDK","text":"<p>The WASI SDK is required for compiling C/C++ code into WASM/WASI binaries. Developers need to download the latest version locally and provide its path to the <code>Makefile</code> within the plugin templates.</p>"},{"location":"plugins/c-cpp/#wasm-tools","title":"wasm-tools","text":"<p>The wasm-tools suite is required for converting compiled WASM binaries into WASM Component binaries, which embed the WIT interfaces. <code>wasm-tools</code> also provides various useful commands for WebAssembly development.</p>"},{"location":"plugins/c-cpp/#wasi-reactor","title":"WASI Reactor","text":"<p>A WASI adapter is required to provide WASI functionalities when creating a WASM component (more information). <code>Wasmtime</code> provides its own adapter, <code>wasi_snapshot_preview1.reactor.wasm</code>, which can be downloaded from their latest releases. When developing plugins using the provided templates, the <code>Makefile</code> will automatically download the latest version into the plugins directory if a local path is not supplied.</p>"},{"location":"plugins/c-cpp/#plugin-template-starters","title":"Plugin Template Starters","text":"<p>Starting plugin development in C/C++ can be complex. To simplify this, we provide starter templates for each plugin type, available for both C and C++. The C++ templates are configured to work with the generated C headers for the API bindings but doesn't provide another abstraction layer between plugins' implementation and the generated bindings. These templates offer a pre-configured structure to organize your source files, generated bindings, vendor dependencies, and build scripts. They also include fully working plugin examples that demonstrate all functionalities provided by the Chipmunk host to plugins, as well as the functionalities plugins need to implement, serving as simple showcases.</p> <p>Each template includes a well-documented <code>Makefile</code> that streamlines the compilation process into a final WebAssembly (WASM) component. This <code>Makefile</code> handles several key steps automatically:</p> <ul> <li>Generating Bindings: Creates the necessary Wasmtime bindings from your WIT definitions.</li> <li>WASI Reactor Management: Downloads the WASI reactor (<code>wasi_snapshot_preview1.reactor.wasm</code>) if a local path isn't provided.</li> <li>Component Conversion: Transforms the intermediate WASM module into a fully-fledged WASM component, embedding its WIT interfaces.</li> </ul>"},{"location":"plugins/c-cpp/#makefile-configuration","title":"Makefile Configuration","text":"<p>The <code>Makefile</code> requires you to specify the paths for the mandatory <code>WASI SDK</code> and <code>Chipmunk WIT Files</code>. You can also optionally provide the path to your locally installed <code>wasi_snapshot_preview1.reactor.wasm</code> file to prevent redundant downloads for each plugin.</p>"},{"location":"plugins/c-cpp/#manual-plugin-development-step-by-step","title":"Manual Plugin Development: Step-by-Step","text":"<p>This section details the manual steps involved in compiling a C/C++ plugin into a WebAssembly Component. This information is useful for understanding the underlying mechanics automated by the provided templates, or for developing plugins from scratch without relying on them.</p>"},{"location":"plugins/c-cpp/#1-generate-wit-bindings","title":"1. Generate WIT Bindings","text":"<p>The first step is to generate the C/C++ bindings from Chipmunk's WIT Definitions. Developers use the wit-bindgen CLI tool for this purpose, specifying the path to the WIT root for the desired API version and the 'world' (plugin type) for which to generate bindings.</p> <p>Here is an example for generating bindings for a parser plugin with API version <code>0.1.0</code>:</p> <pre><code>wit-bindgen c {path_to_plugins_api_crate}/wit/v0.1.0/ -w chipmunk:parser/parse --out-dir .\n</code></pre> <p>This command generates <code>parse.c</code>, <code>parse.h</code>, and <code>parse_component_type.o</code> in the current directory. All generated types and functions from the WIT files can then be referenced and used from <code>parse.h</code>.</p>"},{"location":"plugins/c-cpp/#2-compile-to-webassembly-module","title":"2. Compile to WebAssembly Module","text":"<p>After generating the bindings, compile your C/C++ source code into an intermediate WebAssembly module using the <code>clang</code> or <code>clang++</code> binaries from the WASI SDK. Ensure you set the <code>--sysroot</code> flag to the <code>wasi-sysroot</code> provided by the SDK and <code>-mexec-model</code> to <code>reactor</code>.</p>"},{"location":"plugins/c-cpp/#compiling-a-parser-plugin-in-c","title":"Compiling a Parser Plugin in C","text":"<p>This command compiles the source code of a parser plugin into an intermediate WebAssembly module file:</p> <pre><code>{path_to_wasi_sdk}/bin/clang --sysroot={path_to_wasi_sdk}/share/wasi-sysroot parse.c parse_component_type.o my_parser.c -o my_parser_intermediate.wasm -mexec-model=reactor\n</code></pre>"},{"location":"plugins/c-cpp/#compiling-a-parser-plugin-in-c_1","title":"Compiling a Parser Plugin in C++","text":"<p>C++ plugins require an extra step because <code>clang</code> may warn about mixing C and C++ files. First, compile <code>parse.c</code> separately:</p> <pre><code>{path_to_wasi_sdk}/bin/clang --sysroot={path_to_wasi_sdk}/share/wasi-sysroot parse.c -o parse.o\n</code></pre> <p>Then, compile the C++ source code into the intermediate WebAssembly module using the compiled binary <code>parse.o</code>:</p> <pre><code>{path_to_wasi_sdk}/bin/clang++ --sysroot={path_to_wasi_sdk}/share/wasi-sysroot parse.o parse_component_type.o my_parser.c -o my_parser_intermediate.wasm -mexec-model=reactor\n</code></pre>"},{"location":"plugins/c-cpp/#3-convert-to-webassembly-component","title":"3. Convert to WebAssembly Component","text":"<p>The final step is to convert the compiled WebAssembly module into a WebAssembly Component file. This component includes embedded WIT metadata. This step requires wasm-tools and the <code>wasi_snapshot_preview1.reactor.wasm</code> adapter (which should be downloaded locally, as detailed in the WASI Reactor section).</p> <p>The command to convert the module and generate the final component in our example is:</p> <pre><code>wasm-tools component new my_parser_intermediate.wasm -o my_parser.wasm --adapt=${path_to_wasi_reactor_file}\n</code></pre> <p>This command generates the <code>my_parser.wasm</code> file, which is ready for integration with Chipmunk.</p>"},{"location":"plugins/c-cpp/#memory-ownership","title":"Memory Ownership","text":"<p>Unfortunately, the generated bindings don't explicitly specify memory ownership. For details, refer to the wit-bindgen documentation for C/C++.</p> <p>For convenience, here's a brief summary of the key rules: - Incoming Data: When a host calls a WASM function, the WASM module takes ownership of the memory passed as arguments. The module is responsible for freeing this memory using the <code>*_free</code> functions. - Outgoing Data: When a WASM function returns a value (like a string or a list), the host takes ownership of that memory and is responsible for freeing it.</p>"},{"location":"plugins/c-cpp/#plugin-integration","title":"Plugin Integration","text":"<p>For comprehensive information on integrating plugins with Chipmunk, refer to the following documents:</p> <ul> <li>The integration and metadata sections in the Plugins Development Guide.</li> <li>The Plugin Integration in Chipmunk UI guide.</li> </ul>"},{"location":"plugins/development-guide/","title":"Chipmunk Plugins Development Guide","text":"<p>This guide provides an overview of how to develop plugins for Chipmunk applications. Chipmunk leverages WebAssembly (WASM) and the Component Model to enable a flexible plugin architecture. Whether you\u2019re using Rust or another language that can compile to WASM, this document will help you get started.</p>"},{"location":"plugins/development-guide/#overview","title":"Overview","text":"<p>Chipmunk supports plugins built as WebAssembly components. The plugins system uses WASM Interface Format (WIT) files to define plugin types and the API, allowing developers to write plugins in any language that supports the WASM component model.</p>"},{"location":"plugins/development-guide/#plugin-architecture","title":"Plugin Architecture","text":"<ul> <li>WASM &amp; Component Model: Chipmunk plugins are compiled to WASM and follow the component model.  </li> <li>WIT Files: These files define the plugin API and types, ensuring consistent contracts between plugins and the host application.  </li> <li>Language Flexibility: Although Rust is fully supported (with the provided <code>plugins-api</code>), you can develop plugins in any language that compiles to WASM and adheres to the component model.</li> </ul>"},{"location":"plugins/development-guide/#developing-plugins-with-rust","title":"Developing Plugins with Rust","text":"<p>For Rust developers, we provide a dedicated crate <code>plugins-api</code> that abstracts the details of working directly with WIT files. This crate generates Rust types from WIT, converts WIT contracts into traits and functions, also providing macros to export your Rust types back to WIT, alongside with multiple helpful function.</p>"},{"location":"plugins/development-guide/#prerequisites","title":"Prerequisites","text":""},{"location":"plugins/development-guide/#wasm-wasi-targets","title":"WASM &amp; WASI Targets","text":"<p>Ensure that your Rust development environment is set up with the required targets:</p> <ul> <li>Targets Needed:</li> <li><code>wasm32-unknown-unknown</code></li> <li><code>wasm32-wasip1</code></li> </ul> <p>You can check the installed targets with:</p> <pre><code>rustup target list --installed\n</code></pre> <p>To add the necessary targets, run:</p> <pre><code># Add the wasm32-wasi target:\nrustup target add wasm32-wasi \n\n# Add the wasm32-unknown-unknown target:\nrustup target add wasm32-unknown-unknown\n</code></pre>"},{"location":"plugins/development-guide/#cargo-component","title":"Cargo Component","text":"<p>cargo component is a Cargo subcommand that simplifies creating WebAssembly components with Rust. This tool is required for compiling the example plugins and is highly recommended when developing new plugins.</p>"},{"location":"plugins/development-guide/#wasm-tools-optional","title":"Wasm-tools (Optional)","text":"<p>wasm-tools provide additional CLI and Rust libraries for low-level manipulation of WASM modules. While not required, these tools can be helpful for inspecting, merging, and manipulating WASM modules.</p>"},{"location":"plugins/development-guide/#building-and-integrating-plugins","title":"Building and Integrating Plugins","text":"<p>After developing your plugin, the next step is to build it into a WebAssembly component and integrate it with Chipmunk.</p> <p>To build your plugin:</p> <ul> <li>Development Build: <code>sh   cargo component build</code></li> <li>Release Build: <code>sh   cargo component build -r</code></li> </ul> <p>The build process will generate a <code>.wasm</code> file named after your plugin.</p> <p>To integrate this compiled plugin with Chipmunk, you have two primary methods:</p> <ol> <li> <p>Manual Integration:</p> <ul> <li>Create the Plugin Directory: Create a dedicated directory for your plugin within the appropriate plugin type directory (for example, <code>&lt;HOME&gt;/.chipmunk/plugins/parsers/</code> for parser plugins or <code>&lt;HOME&gt;/.chipmunk/plugins/bytesources/</code> for byte-source plugins) using the plugin name.</li> <li>Copy Artifacts: Place the compiled <code>.wasm</code> file inside this newly created plugin directory. Optionally, you can include a TOML file (e.g., <code>plugin_name.toml</code>) to provide metadata such as the plugin\u2019s name and description. Ensure that both the <code>.wasm</code> binary and the optional <code>.toml</code> metadata file (if present) share the same base name as the plugin directory.</li> <li>Additionally, you can include a <code>README.md</code> file inside the plugin directory. If present, this file will be rendered directly in the Chipmunk UI, allowing you to provide documentation or usage instructions for your plugin.</li> </ul> </li> <li> <p>Using the Chipmunk UI:</p> <ul> <li>Within the Chipmunk application, navigate to the <code>Plugins Manager</code> view.</li> <li>Click the \"Add\" button. This will open a dialog where you can select the plugin's root directory. The name of this selected directory should be the plugin's name, and it should contain your compiled <code>.wasm</code> file (named to match the directory) and any optional <code>.toml</code> metadata file (also named to match) or <code>README.md</code>. Chipmunk will then automatically copy and register the plugin.</li> </ul> </li> </ol>"},{"location":"plugins/development-guide/#developing-plugins-with-cc","title":"Developing Plugins with C/C++","text":"<p>Please refer to C/C++ Plugins Development for detailed info developing plugins in C/C++.</p>"},{"location":"plugins/development-guide/#plugin-configuration","title":"Plugin Configuration","text":"<p>Plugins can define their own configuration schemas. These schemas are presented to users so they can provide the necessary settings. The configuration is then delivered back to the plugin during the session initialization phase. For details on schema definitions, refer to: - The WIT definitions. - The <code>plugins-api</code> crate documentation. - The provided examples.</p>"},{"location":"plugins/development-guide/#plugin-types","title":"Plugin Types","text":"<p>Chipmunk currently supports two main types of plugins:</p>"},{"location":"plugins/development-guide/#parser-plugins","title":"Parser Plugins","text":""},{"location":"plugins/development-guide/#purpose","title":"Purpose:","text":"<p>Parser plugins receive an array of bytes, attempt to parse them, and return the parsed items. They can also define configuration schemas and specify rendering options if needed.</p>"},{"location":"plugins/development-guide/#development-in-rust","title":"Development in Rust:","text":"<ul> <li>Create a struct that implements to the <code>Parser</code> trait defined in the <code>plugins-api</code> crate.</li> <li>Use the <code>parser_export!()</code> macro to export your parser struct.</li> </ul> <p>The <code>plugins-api</code> crate also offers helper functions for logging, access to temp directory and configuration management.</p>"},{"location":"plugins/development-guide/#integration","title":"Integration:","text":"<ul> <li>Use the \"Add\" function in the Chipmunk UI Plugins Manager, as described in the Building and Integrating Plugins section.</li> <li>Alternatively, you can manually create a directory at <code>&lt;HOME&gt;/.chipmunk/plugins/parsers/&lt;plugin-name&gt;/</code> and copy the compiled WASM file (and optionally metadata TOML and README.md files) into this directory.</li> </ul> <p>To get started quickly, you can use the provided parser template. Simply copy the <code>parser</code> directory and modify it to implement your custom parser.  </p> <p>For reference, see the <code>string_parser</code> and <code>dlt_parser</code> examples.</p>"},{"location":"plugins/development-guide/#byte-source-plugins","title":"Byte-Source Plugins","text":""},{"location":"plugins/development-guide/#purpose_1","title":"Purpose:","text":"<p>Byte-source plugins deliver arrays of bytes of a specified length during each load call. These bytes are then processed by a selected parser. Like parser plugins, they can define configuration schemas that are provided during session initialization.</p>"},{"location":"plugins/development-guide/#development-in-rust_1","title":"Development in Rust:","text":"<ul> <li>Create a struct that implements to the <code>ByteSource</code> trait defined in the <code>plugins-api</code> crate.</li> <li>Use the <code>bytesource_export!()</code> macro to export your byte-source struct.</li> </ul> <p>The <code>plugins-api</code> crate again provides helper functions for logging, access to temp directory and configuration management.</p>"},{"location":"plugins/development-guide/#integration_1","title":"Integration:","text":"<ul> <li>Use the \"Add\" function in the Chipmunk UI Plugins Manager, as described in the Building and Integrating Plugins section.</li> <li>Alternatively, you can manually create a directory at <code>&lt;HOME&gt;/.chipmunk/plugins/bytesources/&lt;plugin-name&gt;/</code> and copy the compiled WASM file (and optionally metadata TOML and README.md files) into this directory.</li> </ul> <p>For further details, refer to the <code>file_source</code> example.</p>"},{"location":"plugins/development-guide/#developing-plugins-in-other-languages","title":"Developing Plugins in Other Languages","text":"<p>Plugins can also be developed in any language that supports compiling to WASM with the component model. The API and plugin types are defined via the WIT files. Consult your language\u2019s tooling or community resources for guidance on integrating with the WASM component model.</p>"},{"location":"plugins/development-guide/#useful-tools","title":"Useful Tools","text":""},{"location":"plugins/development-guide/#wit-bindgen","title":"Wit-bindgen","text":"<p>wit-bindgen is a bindings generator for WIT and the WASM Component Model. It supports multiple languages, including Rust, C/C++, C#, and Java, and can help generate the necessary bindings from your WIT files.</p>"},{"location":"plugins/development-guide/#plugins-benchmarking","title":"Plugins Benchmarking:","text":"<p>Chipmunk includes several benchmarks designed to measure the performance of various tasks within your plugins. Each benchmark requires a TOML configuration file that specifies the plugin\u2019s path and other relevant settings. You can refer to the provided templates and examples for more details on how to structure the configuration.  </p> <p>To run the benchmarks, you first need to install the Chipmunk development tool, which is required for managing and executing these benchmarks.  </p> <p>Once installed, you can explore the available benchmarking options with the following command to see detailed information about each benchmark:</p> <pre><code>cargo chipmunk bench core --help\n</code></pre>"},{"location":"plugins/development-guide/#plugin-initialization","title":"Plugin Initialization","text":"<p>This benchmark measures how much time it takes to initialize the plugin with the provided configuration. This is useful for gauging the overhead of loading and setting up the plugin before it begins processing actual data.  </p> <p>To run this benchmark within the Chipmunk repository, use the following command, substituting <code>{path_to_plugin_config_file}</code> with the path to your configuration file:  </p> <pre><code>cargo chipmunk bench core plugin_parser_init -c {path_to_plugin_conig_file}.toml\n</code></pre>"},{"location":"plugins/development-guide/#parser-plugin","title":"Parser Plugin:","text":"<p>This benchmark is designed to evaluate the performance of parser plugins when processing input files. It simulates the real-world scenario of parsing data and allows you to measure how well the plugin performs under various conditions.  </p> <p>Run the benchmark with the following command, replacing <code>{path_to_input_file}</code> with the path to the file you want to parse, and <code>{path_to_plugin_config_file}</code> with the path to the corresponding configuration file:  </p> <pre><code>cargo chipmunk bench core plugin_praser_producer -i {path_to_input_file} -c {path_to_plugin_conig_file}.toml \n</code></pre> <p>For a working example of a parser plugin configuration, refer to the DLT parser config file. This example will help you understand how to structure your configuration for the parser plugin.</p>"},{"location":"plugins/development-guide/#additional-resources","title":"Additional Resources","text":"<ul> <li>WIT Specifications: WIT References</li> <li>Cargo Component: cargo component GitHub Repository</li> <li>Wasm-tools: Wasm-tools GitHub Repository</li> <li>Plugins API Crate Documentation: Plugins API</li> <li>Chipmiunk Contribution: Contribution Page</li> </ul>"},{"location":"plugins/integration-ui/","title":"Plugins Integrations in Chipmunk UI","text":"<p>This guide explains how to manage and use plugins directly within the Chipmunk application's user interface. For details on developing plugins or manually integrating plugin files, please refer to the Plugins Development Guide.</p>"},{"location":"plugins/integration-ui/#plugins-manager","title":"Plugins Manager","text":"<p>The Plugins Manager view shows all your integrated plugins, their status, logs, and associated README files.  From here, you can add new plugins by selecting their directory, eliminating the need for manual file copying.  The Plugins Manager also lets you remove plugins from the system, which permanently deletes their files from the Chipmunk home directory.</p>"},{"location":"plugins/integration-ui/#use-a-parser-plugin","title":"Use a Parser Plugin","text":"<p>To use a parser plugin, first choose your data source (such as files, network streams, or process outputs). Then, select the desired parser from a dropdown list that includes all available parsers, both built-in and plugin-based.</p>"},{"location":"plugins/integration-ui/#visual-overview","title":"Visual Overview","text":"<p>Here is a small overview of the Plugins Manager and how to start a session using a parser plugin:</p> <p></p>"},{"location":"plugins/plugins-api/","title":"Chipmunk Plugins API Crate","text":"<p>This crate simplifies the development of plugins for Chipmunk in Rust. Its source code can be found on GitHub: Plugins API Crate.</p> <p>Chipmunk supports plugins using WebAssembly (Wasm) and the WebAssembly Component Model. It exposes its public API via the WASM Interface Format (WIT), enabling developers to write plugins in any language that supports Wasm and the Component Model.</p> <p>For a detailed guide on developing plugins, refer to the Plugins Development Guide.</p> <p>As this crate is not published on crates.io, the primary and most comprehensive documentation for its API, types, and traits is generated directly from the source code. Developers can access this full documentation by running <code>cargo doc --open</code> from within the crate's directory, which will generate and open the documentation in their web browser.</p>"},{"location":"plugins/plugins-api/#what-this-crate-provides","title":"What This Crate Provides","text":"<p>This crate provides utilities to streamline plugin development in Rust by:</p> <ul> <li>Generating Rust types for <code>WIT</code> definitions.</li> <li>Defining traits that plugins must implement based on their type.</li> <li>Providing helper functions for logging and configuration extraction to reduce boilerplate.</li> <li>Offering export macros to generate the necessary bindings for your structs to function as Chipmunk plugins.</li> </ul>"},{"location":"plugins/plugins-api/#plugin-types","title":"Plugin Types:","text":"<p>Each plugin type is associated with a feature in this crate. A feature must be enabled when adding this crate as a dependency, or the build will fail.</p>"},{"location":"plugins/plugins-api/#parser-plugins","title":"Parser Plugins:","text":"<ul> <li>To develop a parser plugin, enable the <code>parser</code> feature in <code>Cargo.toml</code>.</li> <li>Implement <code>Parser</code> trait on your struct to define a parser plugin.</li> <li>Use <code>parser_export!()</code> macro with your struct to generate the necessary bindings for integration with Chipmunk.</li> <li>Please refer to the rust examples and parser template provided in Chipmunk repo to get started.</li> </ul>"},{"location":"plugins/plugins-api/#byte-source-plugins","title":"Byte-Source Plugins:","text":"<p>NOTE: Byte-Source plugins are not yet supported in Chipmunk. </p> <ul> <li>To develop a byte-source plugin, enable the <code>bytesource</code> feature in <code>Cargo.toml</code>.</li> <li>Implement <code>ByteSource</code> trait on your struct to define a byte-source plugin.</li> <li>Use <code>bytesource_export!()</code> macro with your struct to generate the necessary bindings for integration with Chipmunk.</li> </ul> <ul> <li>Please refer to the examples provided in Chipmunk repo to get started.</li> </ul>"}]}