// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!
#include "parse.h"
#include <stdlib.h>
#include <string.h>

// Imported Functions from `chipmunk:shared/logging@0.1.0`

__attribute__((__import_module__("chipmunk:shared/logging@0.1.0"), __import_name__("log")))
extern void __wasm_import_chipmunk_shared_logging_log(int32_t, uint8_t *, size_t);

// Imported Functions from `chipmunk:shared/sandbox@0.1.0`

__attribute__((__import_module__("chipmunk:shared/sandbox@0.1.0"), __import_name__("temp-directory")))
extern void __wasm_import_chipmunk_shared_sandbox_temp_directory(uint8_t *);

// Exported Functions from `chipmunk:parser/parser@0.1.0`


__attribute__((__weak__, __export_name__("cabi_post_chipmunk:parser/parser@0.1.0#get-config-schemas")))
void __wasm_export_exports_chipmunk_parser_parser_get_config_schemas_post_return(uint8_t * arg0) {
  size_t len3 = *((size_t*) (arg0 + sizeof(void*)));
  if (len3 > 0) {
    uint8_t *ptr4 = *((uint8_t **) (arg0 + 0));
    for (size_t i5 = 0; i5 < len3; i5++) {
      uint8_t *base = ptr4 + i5 * (12*sizeof(void*));
      (void) base;
      if ((*((size_t*) (base + sizeof(void*)))) > 0) {
        free(*((uint8_t **) (base + 0)));
      }
      if ((*((size_t*) (base + (3*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (base + (2*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (base + (4*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (base + (6*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (5*sizeof(void*)))));
          }
          break;
        }
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (base + (7*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          break;
        }
        case 2: {
          break;
        }
        case 3: {
          if ((*((size_t*) (base + (9*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (8*sizeof(void*)))));
          }
          break;
        }
        case 4: {
          break;
        }
        case 5: {
          size_t len = *((size_t*) (base + (9*sizeof(void*))));
          if (len > 0) {
            uint8_t *ptr = *((uint8_t **) (base + (8*sizeof(void*))));
            for (size_t i = 0; i < len; i++) {
              uint8_t *base = ptr + i * (2*sizeof(void*));
              (void) base;
              if ((*((size_t*) (base + sizeof(void*)))) > 0) {
                free(*((uint8_t **) (base + 0)));
              }
            }
            free(ptr);
          }
          break;
        }
        case 6: {
          size_t len0 = *((size_t*) (base + (9*sizeof(void*))));
          if (len0 > 0) {
            uint8_t *ptr1 = *((uint8_t **) (base + (8*sizeof(void*))));
            for (size_t i2 = 0; i2 < len0; i2++) {
              uint8_t *base = ptr1 + i2 * (2*sizeof(void*));
              (void) base;
              if ((*((size_t*) (base + sizeof(void*)))) > 0) {
                free(*((uint8_t **) (base + 0)));
              }
            }
            free(ptr1);
          }
          if ((*((size_t*) (base + (11*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (10*sizeof(void*)))));
          }
          break;
        }
      }
    }
    free(ptr4);
  }
}

__attribute__((__weak__, __export_name__("cabi_post_chipmunk:parser/parser@0.1.0#get-render-options")))
void __wasm_export_exports_chipmunk_parser_parser_get_render_options_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      size_t len = *((size_t*) (arg0 + (2*sizeof(void*))));
      if (len > 0) {
        uint8_t *ptr = *((uint8_t **) (arg0 + sizeof(void*)));
        for (size_t i = 0; i < len; i++) {
          uint8_t *base = ptr + i * (5*sizeof(void*));
          (void) base;
          if ((*((size_t*) (base + sizeof(void*)))) > 0) {
            free(*((uint8_t **) (base + 0)));
          }
          if ((*((size_t*) (base + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (2*sizeof(void*)))));
          }
        }
        free(ptr);
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_chipmunk:parser/parser@0.1.0#init")))
void __wasm_export_exports_chipmunk_parser_parser_init_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + sizeof(void*)))) {
        case 0: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
        case 2: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
        case 3: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_chipmunk:parser/parser@0.1.0#parse")))
void __wasm_export_exports_chipmunk_parser_parser_parse_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      size_t len15 = *((size_t*) (arg0 + (2*sizeof(void*))));
      if (len15 > 0) {
        uint8_t *ptr16 = *((uint8_t **) (arg0 + sizeof(void*)));
        for (size_t i17 = 0; i17 < len15; i17++) {
          uint8_t *base = ptr16 + i17 * (40+14*sizeof(void*));
          (void) base;
          switch ((int32_t) (int32_t) *((uint8_t*) (base + 0))) {
            case 0: {
              break;
            }
            case 1: {
              switch ((int32_t) (int32_t) *((uint8_t*) (base + 8))) {
                case 0: {
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + 16))) {
                    case 0: {
                      if ((*((size_t*) (base + (16+2*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + (16+1*sizeof(void*)))));
                      }
                      break;
                    }
                    case 1: {
                      size_t len = *((size_t*) (base + (16+2*sizeof(void*))));
                      if (len > 0) {
                        uint8_t *ptr = *((uint8_t **) (base + (16+1*sizeof(void*))));
                        for (size_t i = 0; i < len; i++) {
                          uint8_t *base = ptr + i * (2*sizeof(void*));
                          (void) base;
                          if ((*((size_t*) (base + sizeof(void*)))) > 0) {
                            free(*((uint8_t **) (base + 0)));
                          }
                        }
                        free(ptr);
                      }
                      break;
                    }
                  }
                  break;
                }
                case 1: {
                  if ((*((size_t*) (base + (16+1*sizeof(void*))))) > 0) {
                    free(*((uint8_t **) (base + 16)));
                  }
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + (24+2*sizeof(void*))))) {
                    case 0: {
                      break;
                    }
                    case 1: {
                      if ((*((size_t*) (base + (24+4*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + (24+3*sizeof(void*)))));
                      }
                      break;
                    }
                  }
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + (24+5*sizeof(void*))))) {
                    case 0: {
                      break;
                    }
                    case 1: {
                      if ((*((size_t*) (base + (24+7*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + (24+6*sizeof(void*)))));
                      }
                      break;
                    }
                  }
                  size_t len0 = *((size_t*) (base + (24+9*sizeof(void*))));
                  if (len0 > 0) {
                    uint8_t *ptr1 = *((uint8_t **) (base + (24+8*sizeof(void*))));
                    for (size_t i2 = 0; i2 < len0; i2++) {
                      uint8_t *base = ptr1 + i2 * 8;
                      (void) base;
                    }
                    free(ptr1);
                  }
                  size_t len3 = *((size_t*) (base + (24+11*sizeof(void*))));
                  if (len3 > 0) {
                    uint8_t *ptr4 = *((uint8_t **) (base + (24+10*sizeof(void*))));
                    for (size_t i5 = 0; i5 < len3; i5++) {
                      uint8_t *base = ptr4 + i5 * 1;
                      (void) base;
                    }
                    free(ptr4);
                  }
                  break;
                }
                case 2: {
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + 16))) {
                    case 0: {
                      if ((*((size_t*) (base + (16+2*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + (16+1*sizeof(void*)))));
                      }
                      break;
                    }
                    case 1: {
                      size_t len6 = *((size_t*) (base + (16+2*sizeof(void*))));
                      if (len6 > 0) {
                        uint8_t *ptr7 = *((uint8_t **) (base + (16+1*sizeof(void*))));
                        for (size_t i8 = 0; i8 < len6; i8++) {
                          uint8_t *base = ptr7 + i8 * (2*sizeof(void*));
                          (void) base;
                          if ((*((size_t*) (base + sizeof(void*)))) > 0) {
                            free(*((uint8_t **) (base + 0)));
                          }
                        }
                        free(ptr7);
                      }
                      break;
                    }
                  }
                  if ((*((size_t*) (base + (24+3*sizeof(void*))))) > 0) {
                    free(*((uint8_t **) (base + (24+2*sizeof(void*)))));
                  }
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + (32+4*sizeof(void*))))) {
                    case 0: {
                      break;
                    }
                    case 1: {
                      if ((*((size_t*) (base + (32+6*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + (32+5*sizeof(void*)))));
                      }
                      break;
                    }
                  }
                  switch ((int32_t) (int32_t) *((uint8_t*) (base + (32+7*sizeof(void*))))) {
                    case 0: {
                      break;
                    }
                    case 1: {
                      if ((*((size_t*) (base + (32+9*sizeof(void*))))) > 0) {
                        free(*((uint8_t **) (base + (32+8*sizeof(void*)))));
                      }
                      break;
                    }
                  }
                  size_t len9 = *((size_t*) (base + (32+11*sizeof(void*))));
                  if (len9 > 0) {
                    uint8_t *ptr10 = *((uint8_t **) (base + (32+10*sizeof(void*))));
                    for (size_t i11 = 0; i11 < len9; i11++) {
                      uint8_t *base = ptr10 + i11 * 8;
                      (void) base;
                    }
                    free(ptr10);
                  }
                  size_t len12 = *((size_t*) (base + (32+13*sizeof(void*))));
                  if (len12 > 0) {
                    uint8_t *ptr13 = *((uint8_t **) (base + (32+12*sizeof(void*))));
                    for (size_t i14 = 0; i14 < len12; i14++) {
                      uint8_t *base = ptr13 + i14 * 1;
                      (void) base;
                    }
                    free(ptr13);
                  }
                  break;
                }
              }
              break;
            }
          }
        }
        free(ptr16);
      }
      break;
    }
    case 1: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + sizeof(void*)))) {
        case 0: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (2*sizeof(void*)))));
          }
          break;
        }
        case 2: {
          break;
        }
        case 3: {
          break;
        }
      }
      break;
    }
  }
}

// Canonical ABI intrinsics

__attribute__((__weak__, __export_name__("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void) old_size;
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

__attribute__((__aligned__(sizeof(void*))))
static uint8_t RET_AREA[(4*sizeof(void*))];

// Helper Functions

void chipmunk_shared_sandbox_result_string_string_free(chipmunk_shared_sandbox_result_string_string_t *ptr) {
  if (!ptr->is_err) {
    parse_string_free(&ptr->val.ok);
  } else {
    parse_string_free(&ptr->val.err);
  }
}

void chipmunk_shared_shared_types_init_error_free(chipmunk_shared_shared_types_init_error_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      parse_string_free(&ptr->val.config);
      break;
    }
    case 1: {
      parse_string_free(&ptr->val.io);
      break;
    }
    case 2: {
      parse_string_free(&ptr->val.unsupported);
      break;
    }
    case 3: {
      parse_string_free(&ptr->val.other);
      break;
    }
  }
}

void parse_list_string_free(parse_list_string_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    parse_string_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      parse_string_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void chipmunk_shared_shared_types_config_value_free(chipmunk_shared_shared_types_config_value_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      break;
    }
    case 1: {
      break;
    }
    case 2: {
      break;
    }
    case 3: {
      parse_string_free(&ptr->val.text);
      break;
    }
    case 4: {
      parse_list_string_free(&ptr->val.directories);
      break;
    }
    case 5: {
      parse_list_string_free(&ptr->val.files);
      break;
    }
    case 6: {
      parse_string_free(&ptr->val.dropdown);
      break;
    }
  }
}

void chipmunk_shared_shared_types_config_item_free(chipmunk_shared_shared_types_config_item_t *ptr) {
  parse_string_free(&ptr->id);
  chipmunk_shared_shared_types_config_value_free(&ptr->value);
}

void parse_tuple2_list_string_string_free(parse_tuple2_list_string_string_t *ptr) {
  parse_list_string_free(&ptr->f0);
  parse_string_free(&ptr->f1);
}

void chipmunk_shared_shared_types_config_schema_type_free(chipmunk_shared_shared_types_config_schema_type_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      break;
    }
    case 1: {
      break;
    }
    case 2: {
      break;
    }
    case 3: {
      parse_string_free(&ptr->val.text);
      break;
    }
    case 5: {
      parse_list_string_free(&ptr->val.files);
      break;
    }
    case 6: {
      parse_tuple2_list_string_string_free(&ptr->val.dropdown);
      break;
    }
  }
}

void parse_option_string_free(parse_option_string_t *ptr) {
  if (ptr->is_some) {
    parse_string_free(&ptr->val);
  }
}

void chipmunk_shared_shared_types_config_schema_item_free(chipmunk_shared_shared_types_config_schema_item_t *ptr) {
  parse_string_free(&ptr->id);
  parse_string_free(&ptr->title);
  parse_option_string_free(&ptr->description);
  chipmunk_shared_shared_types_config_schema_type_free(&ptr->input_type);
}

void chipmunk_parser_parse_types_parsed_message_free(chipmunk_parser_parse_types_parsed_message_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      parse_string_free(&ptr->val.line);
      break;
    }
    case 1: {
      break;
    }
  }
}

void parse_list_u64_free(parse_list_u64_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint64_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void parse_list_u8_free(parse_list_u8_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    uint8_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
    }
    free(list_ptr);
  }
}

void chipmunk_parser_parse_types_attachment_free(chipmunk_parser_parse_types_attachment_t *ptr) {
  parse_string_free(&ptr->name);
  parse_list_u64_free(&ptr->messages);
  parse_list_u8_free(&ptr->data);
}

void chipmunk_parser_parse_types_tuple2_parsed_message_attachment_free(chipmunk_parser_parse_types_tuple2_parsed_message_attachment_t *ptr) {
  chipmunk_parser_parse_types_parsed_message_free(&ptr->f0);
  chipmunk_parser_parse_types_attachment_free(&ptr->f1);
}

void chipmunk_parser_parse_types_parse_yield_free(chipmunk_parser_parse_types_parse_yield_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      chipmunk_parser_parse_types_parsed_message_free(&ptr->val.message);
      break;
    }
    case 1: {
      chipmunk_parser_parse_types_attachment_free(&ptr->val.attachment);
      break;
    }
    case 2: {
      chipmunk_parser_parse_types_tuple2_parsed_message_attachment_free(&ptr->val.message_and_attachment);
      break;
    }
  }
}

void chipmunk_parser_parse_types_option_parse_yield_free(chipmunk_parser_parse_types_option_parse_yield_t *ptr) {
  if (ptr->is_some) {
    chipmunk_parser_parse_types_parse_yield_free(&ptr->val);
  }
}

void chipmunk_parser_parse_types_parse_return_free(chipmunk_parser_parse_types_parse_return_t *ptr) {
  chipmunk_parser_parse_types_option_parse_yield_free(&ptr->value);
}

void chipmunk_parser_parse_types_parse_error_free(chipmunk_parser_parse_types_parse_error_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      parse_string_free(&ptr->val.unrecoverable);
      break;
    }
    case 1: {
      parse_string_free(&ptr->val.parse);
      break;
    }
  }
}

void chipmunk_parser_parse_types_column_info_free(chipmunk_parser_parse_types_column_info_t *ptr) {
  parse_string_free(&ptr->caption);
  parse_string_free(&ptr->description);
}

void chipmunk_parser_parse_types_list_column_info_free(chipmunk_parser_parse_types_list_column_info_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    chipmunk_parser_parse_types_column_info_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      chipmunk_parser_parse_types_column_info_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void chipmunk_parser_parse_types_columns_render_options_free(chipmunk_parser_parse_types_columns_render_options_t *ptr) {
  chipmunk_parser_parse_types_list_column_info_free(&ptr->columns);
}

void chipmunk_parser_parse_types_option_columns_render_options_free(chipmunk_parser_parse_types_option_columns_render_options_t *ptr) {
  if (ptr->is_some) {
    chipmunk_parser_parse_types_columns_render_options_free(&ptr->val);
  }
}

void chipmunk_parser_parse_types_render_options_free(chipmunk_parser_parse_types_render_options_t *ptr) {
  chipmunk_parser_parse_types_option_columns_render_options_free(&ptr->columns_options);
}

void exports_chipmunk_parser_parser_init_error_free(exports_chipmunk_parser_parser_init_error_t *ptr) {
  chipmunk_shared_shared_types_init_error_free(ptr);
}

void exports_chipmunk_parser_parser_config_item_free(exports_chipmunk_parser_parser_config_item_t *ptr) {
  chipmunk_shared_shared_types_config_item_free(ptr);
}

void exports_chipmunk_parser_parser_config_schema_item_free(exports_chipmunk_parser_parser_config_schema_item_t *ptr) {
  chipmunk_shared_shared_types_config_schema_item_free(ptr);
}

void exports_chipmunk_parser_parser_render_options_free(exports_chipmunk_parser_parser_render_options_t *ptr) {
  chipmunk_parser_parse_types_render_options_free(ptr);
}

void exports_chipmunk_parser_parser_parse_return_free(exports_chipmunk_parser_parser_parse_return_t *ptr) {
  chipmunk_parser_parse_types_parse_return_free(ptr);
}

void exports_chipmunk_parser_parser_parse_error_free(exports_chipmunk_parser_parser_parse_error_t *ptr) {
  chipmunk_parser_parse_types_parse_error_free(ptr);
}

void exports_chipmunk_parser_parser_list_config_schema_item_free(exports_chipmunk_parser_parser_list_config_schema_item_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_chipmunk_parser_parser_config_schema_item_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_chipmunk_parser_parser_config_schema_item_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_chipmunk_parser_parser_list_config_item_free(exports_chipmunk_parser_parser_list_config_item_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_chipmunk_parser_parser_config_item_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_chipmunk_parser_parser_config_item_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_chipmunk_parser_parser_result_void_init_error_free(exports_chipmunk_parser_parser_result_void_init_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
    exports_chipmunk_parser_parser_init_error_free(&ptr->val.err);
  }
}

void parse_option_u64_free(parse_option_u64_t *ptr) {
  if (ptr->is_some) {
  }
}

void exports_chipmunk_parser_parser_list_parse_return_free(exports_chipmunk_parser_parser_list_parse_return_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_chipmunk_parser_parser_parse_return_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_chipmunk_parser_parser_parse_return_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_chipmunk_parser_parser_result_list_parse_return_parse_error_free(exports_chipmunk_parser_parser_result_list_parse_return_parse_error_t *ptr) {
  if (!ptr->is_err) {
    exports_chipmunk_parser_parser_list_parse_return_free(&ptr->val.ok);
  } else {
    exports_chipmunk_parser_parser_parse_error_free(&ptr->val.err);
  }
}

void parse_string_set(parse_string_t *ret, const char*s) {
  ret->ptr = (uint8_t*) s;
  ret->len = strlen(s);
}

void parse_string_dup(parse_string_t *ret, const char*s) {
  ret->len = strlen(s);
  ret->ptr = (uint8_t*) cabi_realloc(NULL, 0, 1, ret->len * 1);
  memcpy(ret->ptr, s, ret->len * 1);
}

void parse_string_free(parse_string_t *ret) {
  if (ret->len > 0) {
    free(ret->ptr);
  }
  ret->ptr = NULL;
  ret->len = 0;
}

// Component Adapters

void chipmunk_shared_logging_log(chipmunk_shared_logging_level_t level, parse_string_t *msg) {
  __wasm_import_chipmunk_shared_logging_log((int32_t) level, (uint8_t *) (*msg).ptr, (*msg).len);
}

bool chipmunk_shared_sandbox_temp_directory(parse_string_t *ret, parse_string_t *err) {
  __attribute__((__aligned__(sizeof(void*))))
  uint8_t ret_area[(3*sizeof(void*))];
  uint8_t *ptr = (uint8_t *) &ret_area;
  __wasm_import_chipmunk_shared_sandbox_temp_directory(ptr);
  chipmunk_shared_sandbox_result_string_string_t result;
  switch ((int32_t) *((uint8_t*) (ptr + 0))) {
    case 0: {
      result.is_err = false;
      result.val.ok = (parse_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
    case 1: {
      result.is_err = true;
      result.val.err = (parse_string_t) { (uint8_t*)(*((uint8_t **) (ptr + sizeof(void*)))), (*((size_t*) (ptr + (2*sizeof(void*))))) };
      break;
    }
  }
  if (!result.is_err) {
    *ret = result.val.ok;
    return 1;
  } else {
    *err = result.val.err;
    return 0;
  }
}

__attribute__((__export_name__("chipmunk:parser/parser@0.1.0#get-version")))
uint8_t * __wasm_export_exports_chipmunk_parser_parser_get_version(void) {
  exports_chipmunk_parser_parser_version_t ret;
  exports_chipmunk_parser_parser_get_version(&ret);
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  *((int16_t*)(ptr + 0)) = (int32_t) ((ret).major);
  *((int16_t*)(ptr + 2)) = (int32_t) ((ret).minor);
  *((int16_t*)(ptr + 4)) = (int32_t) ((ret).patch);
  return ptr;
}

__attribute__((__export_name__("chipmunk:parser/parser@0.1.0#get-config-schemas")))
uint8_t * __wasm_export_exports_chipmunk_parser_parser_get_config_schemas(void) {
  exports_chipmunk_parser_parser_list_config_schema_item_t ret;
  exports_chipmunk_parser_parser_get_config_schemas(&ret);
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  *((size_t*)(ptr + sizeof(void*))) = (ret).len;
  *((uint8_t **)(ptr + 0)) = (uint8_t *) (ret).ptr;
  return ptr;
}

__attribute__((__export_name__("chipmunk:parser/parser@0.1.0#get-render-options")))
uint8_t * __wasm_export_exports_chipmunk_parser_parser_get_render_options(void) {
  exports_chipmunk_parser_parser_render_options_t ret;
  exports_chipmunk_parser_parser_get_render_options(&ret);
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if (((ret).columns_options).is_some) {
    const chipmunk_parser_parse_types_columns_render_options_t *payload0 = &((ret).columns_options).val;
    *((int8_t*)(ptr + 0)) = 1;
    *((size_t*)(ptr + (2*sizeof(void*)))) = ((*payload0).columns).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) ((*payload0).columns).ptr;
    *((int16_t*)(ptr + (3*sizeof(void*)))) = (int32_t) ((*payload0).min_width);
    *((int16_t*)(ptr + (2+3*sizeof(void*)))) = (int32_t) ((*payload0).max_width);
  } else {
    *((int8_t*)(ptr + 0)) = 0;
  }
  return ptr;
}

__attribute__((__export_name__("chipmunk:parser/parser@0.1.0#init")))
uint8_t * __wasm_export_exports_chipmunk_parser_parser_init(int32_t arg, uint8_t * arg0, size_t arg1) {
  exports_chipmunk_parser_parser_parser_config_t arg2 = (chipmunk_parser_parse_types_parser_config_t) {
    (chipmunk_parser_parse_types_level_t) arg,
  };
  exports_chipmunk_parser_parser_list_config_item_t arg3 = (exports_chipmunk_parser_parser_list_config_item_t) { (exports_chipmunk_parser_parser_config_item_t*)(arg0), (arg1) };
  exports_chipmunk_parser_parser_result_void_init_error_t ret;
  exports_chipmunk_parser_parser_init_error_t err;
  ret.is_err = !exports_chipmunk_parser_parser_init(&arg2, &arg3, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_chipmunk_parser_parser_init_error_t *payload4 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    switch ((int32_t) (*payload4).tag) {
      case 0: {
        const parse_string_t *payload5 = &(*payload4).val.config;
        *((int8_t*)(ptr + sizeof(void*))) = 0;
        *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload5).len;
        *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload5).ptr;
        break;
      }
      case 1: {
        const parse_string_t *payload6 = &(*payload4).val.io;
        *((int8_t*)(ptr + sizeof(void*))) = 1;
        *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload6).len;
        *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload6).ptr;
        break;
      }
      case 2: {
        const parse_string_t *payload7 = &(*payload4).val.unsupported;
        *((int8_t*)(ptr + sizeof(void*))) = 2;
        *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload7).len;
        *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload7).ptr;
        break;
      }
      case 3: {
        const parse_string_t *payload8 = &(*payload4).val.other;
        *((int8_t*)(ptr + sizeof(void*))) = 3;
        *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload8).len;
        *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload8).ptr;
        break;
      }
    }
  } else {
    *((int8_t*)(ptr + 0)) = 0;
  }
  return ptr;
}

__attribute__((__export_name__("chipmunk:parser/parser@0.1.0#parse")))
uint8_t * __wasm_export_exports_chipmunk_parser_parser_parse(uint8_t * arg, size_t arg0, int32_t arg1, int64_t arg2) {
  parse_option_u64_t option;
  switch (arg1) {
    case 0: {
      option.is_some = false;
      break;
    }
    case 1: {
      option.is_some = true;
      option.val = (uint64_t) (arg2);
      break;
    }
  }
  parse_list_u8_t arg3 = (parse_list_u8_t) { (uint8_t*)(arg), (arg0) };
  exports_chipmunk_parser_parser_result_list_parse_return_parse_error_t ret;
  exports_chipmunk_parser_parser_list_parse_return_t ok;
  exports_chipmunk_parser_parser_parse_error_t err;
  ret.is_err = !exports_chipmunk_parser_parser_parse(&arg3, option.is_some ? &(option.val) : NULL, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_chipmunk_parser_parser_parse_error_t *payload21 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    switch ((int32_t) (*payload21).tag) {
      case 0: {
        const parse_string_t *payload22 = &(*payload21).val.unrecoverable;
        *((int8_t*)(ptr + sizeof(void*))) = 0;
        *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload22).len;
        *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload22).ptr;
        break;
      }
      case 1: {
        const parse_string_t *payload23 = &(*payload21).val.parse;
        *((int8_t*)(ptr + sizeof(void*))) = 1;
        *((size_t*)(ptr + (3*sizeof(void*)))) = (*payload23).len;
        *((uint8_t **)(ptr + (2*sizeof(void*)))) = (uint8_t *) (*payload23).ptr;
        break;
      }
      case 2: {
        *((int8_t*)(ptr + sizeof(void*))) = 2;
        break;
      }
      case 3: {
        *((int8_t*)(ptr + sizeof(void*))) = 3;
        break;
      }
    }
  } else {
    const exports_chipmunk_parser_parser_list_parse_return_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (2*sizeof(void*)))) = (*payload).len;
    *((uint8_t **)(ptr + sizeof(void*))) = (uint8_t *) (*payload).ptr;
  }
  return ptr;
}

// Ensure that the *_component_type.o object is linked in

extern void __component_type_object_force_link_parse(void);
void __component_type_object_force_link_parse_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_parse();
}
