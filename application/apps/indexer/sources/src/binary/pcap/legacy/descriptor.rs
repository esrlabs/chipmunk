use descriptor::{SourceDescriptor, CommonDescriptor};
use file_tools::is_binary;
use stypes::{ComponentOptions, NativeError, NativeErrorKind, SessionAction, Severity};
use crate::*;
use super::PcapLegacyByteSourceFromFile;

const PCAP_SOURCE_UUID: uuid::Uuid = uuid::Uuid::from_bytes([
    0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10,
]);

#[derive(Default)]
pub struct Descriptor {}

     pub fn factory(
        origin: &SessionAction,
        _options: &[stypes::Field],
    ) -> Result<Option<(Sources, Option<String>)>, stypes::NativeError> {
        let filepath = match origin {
            SessionAction::File(file) => file,
            SessionAction::Files(..) | SessionAction::Source | SessionAction::ExportRaw(.. ) => {
                return Err(NativeError {
                    severity: Severity::ERROR,
                    kind: NativeErrorKind::Configuration,
                    message: Some("Pcap Legacy Source cannot be applied in this context".to_owned())
                })
            }
        };
        Ok(Some((Sources::Pcap(PcapLegacyByteSourceFromFile::new(filepath)?), Some("Pcap".to_owned()))))
    }


impl CommonDescriptor for Descriptor {
    fn is_compatible(&self, origin: &SessionAction) -> bool {
        let files = match origin {
            SessionAction::File(filepath) => {
                vec![filepath]
            }
            SessionAction::Files(files) => files.iter().collect(),
            SessionAction::Source | SessionAction::ExportRaw(..) => {
                return false;
            }
        };
        files.iter().any(|fp| {
            fp.extension()
                .map(|ext| ext.eq_ignore_ascii_case("pcap"))
                .unwrap_or_default()
        }) &&        
        // If at least some file doesn't exist or not binary - do not recommend this source
        !files
            .into_iter()
            .any(|f| !f.exists() || !is_binary(f.to_string_lossy().to_string()).unwrap_or_default())
    }
    fn ident(&self) -> stypes::Ident {
        stypes::Ident {
            name: String::from("PCAP Source"),
            desc: String::from("PCAP Source"),
            io: stypes::IODataType::NetworkFramePayload,
            uuid: PCAP_SOURCE_UUID,
        }
    }

}

impl SourceDescriptor for Descriptor {}

pub fn get_default_options() -> ComponentOptions {
    ComponentOptions {
        uuid: PCAP_SOURCE_UUID,
        fields: Vec::new(),
    }
}

#[cfg(test)]
mod tests {

    use env_logger;

    use crate::{
        binary::pcap::legacy::PcapLegacyByteSource, tests::general_source_reload_test, ByteSource,
    };

    #[tokio::test(flavor = "multi_thread")]
    async fn test_read_one_message_from_pcap() {
        let _ = env_logger::try_init();

        const SAMPLE_PCAP_DATA: &[u8] = &[
            0xd4, 0xc3, 0xb2, 0xa1, // Magic Number (4 bytes) = d4 c3 b2 a1
            0x02, 0x00, // Version Major (2 bytes) = 02 00
            0x04, 0x00, // Version Minor (2 bytes) = 04 00
            0x00, 0x00, 0x00, 0x00, // Timezone (4 bytes) = 00 00 00 00
            0x00, 0x00, 0x00, 0x00, // Timestamp Accuracy (4 bytes) = 00 00 00 00
            0x00, 0x00, 0x04, 0x00, // Snap Length (4 bytes)
            0x01, 0x00, 0x00, 0x00, // Link-Layer Type (4 bytes)
            // Packet Header 16 byte
            0xeb, 0x15, 0x88, 0x60, 0xe6, 0x7f, 0x04, 0x00, 0x62, 0x00, 0x00, 0x00, 0x62, 0x00,
            0x00, 0x00, //
            // start of ethernet packet -------------------
            0xb8, 0x27, 0xeb, 0x1d, 0x24, 0xc9, 0xb8, 0x27, 0xeb, 0x98, 0x94, 0xfa, 0x08, 0x00,
            0x45, 0x00, 0x00, 0x54, 0xa0, 0x48, 0x40, 0x00, 0x40, 0x11, 0x29, 0x85, 0xac, 0x16,
            0x0c, 0x4f, 0xac, 0x16, 0x0c,
            0x50, // start of udp frame  -------------------------
            0xc3, 0x50, 0xc3, 0x50, 0x00, 0x40, 0x8e, 0xe3, //
            // start of udp payload 56 bytes ---------------------------
            0xff, 0xff, 0x81, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01,
            0x02, 0x00, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x10,
            0x01, 0x03, 0x00, 0x01, 0x01, 0x00, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x0c, 0x00, 0x09, 0x04, 0x00, 0xac, 0x16, 0x0c, 0x4f, 0x00, 0x11, 0x75, 0x30,
        ];

        let udp_payload = &SAMPLE_PCAP_DATA[82..=137];
        let pcap_file = std::io::Cursor::new(SAMPLE_PCAP_DATA);

        let mut source = PcapLegacyByteSource::new(pcap_file).expect("cannot create source");
        let reload_info = source.load(None).await.expect("reload should work");
        println!("reload_info: {:?}", reload_info);
        let slice = source.current_slice();
        println!("slice: {:x?}", slice);
        assert_eq!(slice.len(), 56);
        assert_eq!(slice, udp_payload);
    }

    #[tokio::test(flavor = "multi_thread")]
    async fn test_general_source_reload() {
        // This is part of the file "chipmunk/application/developing/resources".
        // In this test we just need enough bytes to call reload twice on it, and we will not
        // call parse on any of this data.
        const SAMPLE_PCAP_DATA: &[u8] = &[
            0xd4, 0xc3, 0xb2, 0xa1, 0x02, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x52, 0x90, 0x5a, 0x64,
            0xa4, 0xd8, 0x0e, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x6e, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x5e, 0x40, 0xff, 0xfb, 0xb8, 0x27, 0xeb, 0x1d, 0x24, 0xc9, 0x08, 0x00, 0x45, 0x00,
            0x00, 0x60, 0x16, 0x99, 0x00, 0x00, 0x01, 0x11, 0x40, 0x17, 0xc0, 0xa8, 0xb2, 0x3a,
            0xef, 0xff, 0xff, 0xfa, 0x9c, 0x40, 0x9c, 0x40, 0x00, 0x4c, 0x63, 0x3b, 0xff, 0xff,
            0x81, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x00,
            0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x20, 0x00, 0x7b,
            0x00, 0x01, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18,
            0x00, 0x09, 0x04, 0x00, 0xc0, 0xa8, 0xb2, 0x3a, 0x00, 0x11, 0x75, 0x30, 0x00, 0x10,
            0x04, 0x00, 0xc0, 0xa8, 0xb2, 0x3a, 0x00, 0x06, 0x75, 0x30, 0x52, 0x90, 0x5a, 0x64,
            0x08, 0xda, 0x0e, 0x00, 0x62, 0x00, 0x00, 0x00, 0x62, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x5e, 0x40, 0xff, 0xfb, 0xb8, 0x27, 0xeb, 0x1d, 0x24, 0xc9, 0x08, 0x00, 0x45, 0x00,
            0x00, 0x54, 0x3a, 0xb4, 0x00, 0x00, 0x40, 0x11, 0x00, 0x00, 0xc0, 0xa8, 0xb2, 0x3a,
            0xc0, 0xa8, 0xb2, 0x3a, 0x9c, 0x40, 0x9c, 0x40, 0x00, 0x40, 0xe6, 0x17, 0xff, 0xff,
            0x81, 0x00, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x02, 0x00,
            0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x06, 0x00, 0x00, 0x10, 0x00, 0x7b,
            0x00, 0x01, 0x01, 0x00, 0x00, 0x03, 0x00, 0x00, 0x01, 0x41, 0x00, 0x00, 0x00, 0x0c,
            0x00, 0x09, 0x04, 0x00, 0xc0, 0xa8, 0xb2, 0x3a, 0x00, 0x11, 0x75, 0x30, 0x52, 0x90,
        ];

        let pcap_file = std::io::Cursor::new(SAMPLE_PCAP_DATA);

        let mut source = PcapLegacyByteSource::new(pcap_file).expect("cannot create source");

        general_source_reload_test(&mut source).await;
    }
}
