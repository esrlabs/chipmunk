const path = require('path');
const colors = require('colors/safe');
const fs = require('fs');
const os = require('os');

const CLI_FLAGS = {
    skipNpm: process.argv.indexOf('--skip-npm') !== -1
};

const PLATFORMS = {
    darwin  : 'darwin',
    linux   : 'linux',
    win32   : 'win32',
};

const sh = function(task, path, ...commands){
    const jake = require('jake');
    jake.exec(commands.map((command) => {
        return `(cd ${path} && ${command})`;
    }), { printStdout: true, printStderr: true }, () => {
        task.complete();
    });
};

const shNotBreakble = function(task, path, ...commands){
    const jake = require('jake');
    jake.exec(commands.map((command) => {
        return `(cd ${path} && ${command})`;
    }), { printStdout: true, printStderr: true, breakOnError: false }, () => {
        task.complete();
    });
};


class FSController {

    constructor() {
        this._EEntityTypes = {
            file: Symbol(),
            folder: Symbol(),
            all: Symbol()
        };
    }

    getEntities(folder, type) {
        if (!fs.existsSync(folder)) {
            return [];
        }
        const entities = fs.readdirSync(folder);
        if (!(entities instanceof Array)) {
            return [];
        }
        type = typeof type === 'undefined' ? this._EEntityTypes.all : type;
        if (type === this._EEntityTypes.all) {
            return entities;
        }
        const results = [];
        entities.forEach((entity) => {
            const stat = fs.statSync(path.resolve(folder, entity));
            if ((type === this._EEntityTypes.file && !stat.isDirectory()) || (type === this._EEntityTypes.folder && stat.isDirectory())) {
                results.push(entity);
            }
        });
        return results;
    }

    getFiles(folder) {
        return this.getEntities(folder, this._EEntityTypes.file);
    }

    getFolders(folder) {
        return this.getEntities(folder, this._EEntityTypes.folder);
    }

    isFileInFolder(file, folder) {
        return fs.existsSync(path.normalize(path.resolve(folder, file)));
    }
}

const fsController = new FSController();

const APP_FOLDER = 'application';
const CLIENT_FOLDER = 'client.core';
const CLIENT_NPM_LIBS = 'client.libs/logviewer.client.components';
const PATH_COMPRESSED_PLUGINS = path.normalize(path.resolve(__dirname, 'electron/dist/compiled/plugins'));
const PLUGIN_IPC_LIB = 'node.libs/logviewer.plugin.ipc';
const ELECTRON_FOLDER = 'electron';
const PLATFORM_FOLDER = 'platform';
const CLIENT_NPM_LIBS_LIST = [
    'logviewer-client-containers',
    'logviewer-client-primitive',
    'logviewer-client-complex',
];

const PLATFORM_EXCEPTION_FOLDERS = [
    'platform',
    'client.plugins',
    'sandbox',
    'node_modules',
    'build',
    'dist',
    'client.libs'
];
const PROJECTS_EXCEPTION_FOLDERS = [
    'client.plugins',
    'sandbox',
    'node_modules',
    'build',
    'dist',
    'client.libs'
];
const LOGO_FILE = 'logo.ascii';

function findAllProjects(target, exceptions, journal = {}) {
    exceptions = exceptions instanceof Array ? exceptions : [];
    const folders = fsController.getFolders(target);
    const projects = [];
    folders.forEach((folder) => {
        if (exceptions.indexOf(folder) !== -1) {
            return;
        }
        const nested = findAllProjects(path.normalize(path.resolve(target, folder)), exceptions, journal);
        projects.push(...nested);
        if (fsController.isFileInFolder(path.normalize(path.resolve(target, folder, 'package.json')))) {
            if (journal[path.basename(folder)] === void 0) {
                projects.push(path.normalize(path.resolve(target, folder)));
                journal[path.basename(folder)] = true;
            }
        }
    });
    return projects;
}

function logo(){
    if (logo.__show !== void 0) { 
        return;
    }
    const file = path.resolve(__dirname, LOGO_FILE);
    if (!fs.existsSync(file)) {
        return;
    }
    const buffer = fs.readFileSync(file);
    logo.__show = true;
    return console.log(colors.yellow(buffer.toString('utf8')));
}

function echo(msg) {
    return `echo "${msg}"`;
}

function echoDec(msg, filler = '*', colorFunc = null) {
    msg = `${filler.repeat(2)} ${msg} ${filler.repeat(2)} `;
    if (colorFunc !== null) {
        return `echo "${colorFunc(`\n${filler.repeat(msg.length - 1)}\n${msg}\n${filler.repeat(msg.length - 1)}\n`)}"` ;
    } else {
        return `echo "\n${filler.repeat(msg.length - 1)}\n${msg}\n${filler.repeat(msg.length - 1)}\n"` ;
    }
}

function getCpCmd() {
    if(process.platform === 'win32') {
        return 'cp -r';
    } else {
        return 'cp -R';
    }
}

namespace('solution', function() {

    task('unlink', function() {
        logo();
        const projects = findAllProjects(path.normalize(__dirname), PLATFORM_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        projects.forEach((folder) => {
            const target = path.normalize(path.resolve(folder, PLATFORM_FOLDER));
            if (!fs.existsSync(target)) {
                return;
            }
            tasks.push(echo(colors.blue(`unlink: ${target}`)));
            tasks.push(`unlink ${target} & exit 0`);
        });
        if (tasks.length === 0) {
            console.log(`Nothing to unlink. All projects arn't bound`);
            return this.complete();
        }
        console.log(`Found ${tasks.length / 2} bound projects. Projects will be unlinked`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('link', function() {
        logo();
        const projects = findAllProjects(path.normalize(__dirname), PLATFORM_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        const platform = path.normalize(path.resolve(__dirname, PLATFORM_FOLDER));
        projects.forEach((folder) => {
            const target = path.normalize(path.resolve(folder, PLATFORM_FOLDER));
            if (fs.existsSync(target)) {
                console.log(`Project ${folder} is already linked. It will be unlinked before to be linked again.`);
                tasks.push(echo(colors.blue(`unlink: ${target}`)));
                tasks.push(`unlink ${target} & exit 0`);
            }
            tasks.push(echo(colors.blue(`link: ${target}`)));
            tasks.push(`ln -s ${platform} ${target}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('clear', function() {
        logo();
        const projects = findAllProjects(path.normalize(__dirname), PROJECTS_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        !CLI_FLAGS.skipNpm && projects.forEach((folder) => {
            const target = path.normalize(path.resolve(folder, 'node_modules'));
            const etc = path.normalize(path.resolve(folder, 'etc'));
            if (fs.existsSync(target)) {
                tasks.push(echo(colors.blue(`clearing: ${target}`)));
                tasks.push(`rm -rf ${target}`);
            }
            fs.existsSync(etc) && tasks.push(`rm -r ${etc}`);
        });
        if (tasks.length === 0) {
            console.log(`No projects to be uninstalled`);
            return this.complete();
        }
        console.log(`Will be uninstalled ${tasks.length} projects.`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('npm-install', function() {
        logo();
        const projects = findAllProjects(path.normalize(__dirname), PROJECTS_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        !CLI_FLAGS.skipNpm && projects.forEach((folder) => {
            const target = path.normalize(path.resolve(folder, 'node_modules'));
            fs.existsSync(target) && tasks.push(`rm -rf ${target}`);
            tasks.push(echoDec(`Installing NPM in: ${folder}`, '*', colors.green));
            tasks.push(`npm install --prefix ${folder}`);
        });
        if (tasks.length === 0) {
            console.log(`No projects to be installed`);
            return this.complete();
        }
        sh(this, '.', ...tasks);
    }, {async: true});

    task('fix-npm-etc', function() {
        const projects = findAllProjects(path.normalize(__dirname), PROJECTS_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        projects.forEach((folder) => {
            const target = path.normalize(path.resolve(folder, 'etc'));
            fs.existsSync(target) && tasks.push(`rm -rf ${target}`);
        });
        if (tasks.length === 0) {
            console.log(`No projects to be installed`);
            return this.complete();
        }
        sh(this, '.', ...tasks);
    }, {async: true});
    
    task('install', ['solution:npm-install', 'solution:fix-npm-etc']);

    task('upgrade', function() {
        logo();
        const projects = findAllProjects(path.normalize(__dirname), PROJECTS_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        projects.forEach((folder) => {
            const packageJson = path.normalize(path.resolve(folder, 'package.json'));
            tasks.push(echoDec(`Checking: ${packageJson}`, '*', colors.green));
            tasks.push(`./node_modules/.bin/npm-check ${folder} -y --no-emoji`);
        });
        if (tasks.length === 0) {
            console.log(`No projects to be upgraded`);
            return this.complete();
        }
        sh(this, '.', ...tasks);
    }, {async: true});

    task('actuality', function() {
        logo();
        const projects = findAllProjects(path.normalize(__dirname), PROJECTS_EXCEPTION_FOLDERS);
        console.log(`Found ${projects.length} projects:\n\t- ${projects.join('\n\t- ')}`);
        const tasks = [];
        projects.forEach((folder) => {
            const packageJson = path.normalize(path.resolve(folder, 'package.json'));
            tasks.push(echoDec(`Checking: ${packageJson}`, '*', colors.green));
            tasks.push(`./node_modules/.bin/npm-check ${folder} --no-emoji`);
        });
        if (tasks.length === 0) {
            console.log(`No projects to be upgraded`);
            return this.complete();
        }
        shNotBreakble(this, '.', ...tasks);
    }, {async: true});

});

namespace('client', function() {
    task('install', function() {
        logo();
        const tasks = [];
        const clientPath = path.normalize(path.resolve(__dirname, CLIENT_FOLDER));
        const clientNodeModules = path.normalize(path.resolve(clientPath, 'node_modules'));
        const clientDist = path.normalize(path.resolve(clientPath, 'dist'));
        if (!CLI_FLAGS.skipNpm && fs.existsSync(clientNodeModules)) {
            tasks.push(echo(colors.blue(`Remove node_modules files: ${clientNodeModules}`)));
            tasks.push(`rm -rf ${clientNodeModules}`);
        }
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        !CLI_FLAGS.skipNpm && tasks.push(echo(colors.blue(`Installing: ${clientPath}`)));
        !CLI_FLAGS.skipNpm && tasks.push(`npm install --prefix ${clientPath}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('link-client-libs', function() {
        logo();
        const tasks = [];
        const clientPath = path.normalize(path.resolve(__dirname, CLIENT_FOLDER));
        const clientNodeModules = path.normalize(path.resolve(clientPath, 'node_modules'));
        const clientLibsPath = path.normalize(path.resolve(__dirname, CLIENT_NPM_LIBS));
        const clientLibsDist = path.normalize(path.resolve(clientLibsPath, 'dist'));
        CLIENT_NPM_LIBS_LIST.forEach((alias) => {
            const clientLib = path.normalize(path.resolve(clientLibsDist, alias));
            const clientLibDest = path.normalize(path.resolve(clientNodeModules, alias));
            if (fs.existsSync(clientLibDest)) {
                console.log(`Project ${clientLibDest} is already linked. It will be unlinked before to be linked again.`);
                tasks.push(echo(colors.blue(`unlink: ${clientLibDest}`)));
                tasks.push(`rm -rf ${clientLibDest} & exit 0`);
            }
            tasks.push(echo(colors.blue(`Coping: ${clientLibDest}`)));
            tasks.push(`${getCpCmd()} ${clientLib} ${clientLibDest}`);
            tasks.push(`rm -rf ${path.normalize(path.resolve(clientPath, 'etc'))}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('link-client-ipc', function() {
        logo();
        const tasks = [];
        const clientPath = path.normalize(path.resolve(__dirname, CLIENT_FOLDER));
        const destElectronIPCPath = path.normalize(path.resolve(clientPath, 'src/app/environment/services/electron.ipc.messages'));
        const destPluginIPCPath = path.normalize(path.resolve(clientPath, 'src/app/environment/services/plugins.ipc.messages'));
        const electronPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const srcElectronIPCPath = path.normalize(path.resolve(electronPath, 'src/controllers/electron.ipc.messages'));
        const srcPluginsIPCPath = path.normalize(path.resolve(electronPath, 'src/controllers/plugin.ipc.messages'));
        tasks.push(echo(colors.blue(`Coping: ${srcElectronIPCPath}`)));
        tasks.push(`rm -rf ${destElectronIPCPath}`);
        tasks.push(`${getCpCmd()} ${srcElectronIPCPath} ${destElectronIPCPath}`);
        tasks.push(`rm -rf ${path.normalize(path.resolve(clientPath, 'etc'))}`);

        tasks.push(echo(colors.blue(`Coping: ${srcPluginsIPCPath}`)));
        tasks.push(`rm -rf ${destPluginIPCPath}`);
        tasks.push(`${getCpCmd()} ${srcPluginsIPCPath} ${destPluginIPCPath}`);
        tasks.push(`rm -rf ${path.normalize(path.resolve(clientPath, 'etc'))}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('build', function() {
        logo();
        const tasks = [];
        const clientPath = path.normalize(path.resolve(__dirname, CLIENT_FOLDER));
        const clientDist = path.normalize(path.resolve(clientPath, 'dist'));
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        tasks.push(echo(colors.blue(`Building: ${clientPath}`)));
        tasks.push(`npm run build --prefix ${clientPath}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['client:install', 'client.npmlibs:all', 'client:link-client-libs', 'client:link-client-ipc', 'client:build']);

});

namespace('plugin.ipc', function() {
    task('build', function() {
        logo();
        const tasks = [];
        const pluginIPCPath = path.normalize(path.resolve(__dirname, PLUGIN_IPC_LIB));
        const pluginIPCNodeModules = path.normalize(path.resolve(pluginIPCPath, 'node_modules'));
        const pluginIPCDist = path.normalize(path.resolve(pluginIPCPath, 'dist'));
        if (!CLI_FLAGS.skipNpm && fs.existsSync(pluginIPCNodeModules)) {
            tasks.push(echo(colors.blue(`Remove node_modules files: ${pluginIPCNodeModules}`)));
            tasks.push(`rm -rf ${pluginIPCNodeModules}`);
        }
        if (fs.existsSync(pluginIPCDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${pluginIPCDist}`)));
            tasks.push(`rm -rf ${pluginIPCDist}`);
        }
        tasks.push(echo(colors.blue(`Building: ${pluginIPCPath}`)));
        !CLI_FLAGS.skipNpm && tasks.push(`npm install --prefix ${pluginIPCPath}`);
        tasks.push(`npm run build --prefix ${pluginIPCPath}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('link-ipc-messages', function() {
        logo();
        const tasks = [];
        const pluginIPCPath = path.normalize(path.resolve(__dirname, PLUGIN_IPC_LIB));
        const pluginIPCMessagesFolder = path.normalize(path.resolve(pluginIPCPath, 'src/ipc.messages'));
        const electronPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronMessagesFolder = path.normalize(path.resolve(electronPath, 'src/controllers/plugin.ipc.messages'));
        if (fs.existsSync(pluginIPCMessagesFolder)) {
            console.log(`Project ${pluginIPCMessagesFolder} is already linked. It will be unlinked before to be linked again.`);
            tasks.push(echo(colors.blue(`unlink: ${pluginIPCMessagesFolder}`)));
            tasks.push(`unlink ${pluginIPCMessagesFolder} & exit 0`);
            tasks.push(`rm -rf ${pluginIPCMessagesFolder} & exit 0`);
        }
        tasks.push(echo(colors.blue(`link: ${pluginIPCMessagesFolder}`)));
        tasks.push(`ln -s ${electronMessagesFolder} ${pluginIPCMessagesFolder}`);
        tasks.push(`rm -rf ${path.normalize(path.resolve(pluginIPCPath, 'etc'))}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['plugin.ipc:link-ipc-messages', 'plugin.ipc:build']);

});

namespace('client.npmlibs', function() {

    task('build', function() {
        logo();
        const tasks = [];
        const clientLibsPath = path.normalize(path.resolve(__dirname, CLIENT_NPM_LIBS));
        const clientLibsDist = path.normalize(path.resolve(clientLibsPath, 'dist'));
        if (fs.existsSync(clientLibsDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientLibsDist}`)));
            tasks.push(`rm -rf ${clientLibsDist}`);
        }
        CLIENT_NPM_LIBS_LIST.forEach((alias) => {
            const libPath = path.normalize(path.resolve(clientLibsPath, `projects/${alias}`));
            const libNodeModules = path.normalize(path.resolve(libPath, `node_modules`));
            if (!CLI_FLAGS.skipNpm && fs.existsSync(libNodeModules)) {
                tasks.push(echo(colors.blue(`Remove node_modules of "${alias}" files: ${libNodeModules}`)));
                tasks.push(`rm -rf ${libNodeModules}`);
            }
            !CLI_FLAGS.skipNpm && tasks.push(echo(colors.blue(`Installing: ${alias}:: ${libPath}`)));
            !CLI_FLAGS.skipNpm && tasks.push(`npm install --prefix ${libPath}`);
            tasks.push(echo(colors.blue(`Building: ${alias}:: ${libPath}`)));
            tasks.push(`npm run build:${alias} --prefix ${clientLibsPath}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['client.npmlibs:build']);

});

namespace('plugin.processes', function() {
    const PATH_DEST = path.normalize(path.resolve(__dirname, 'sandbox/processes'));
    const PATH_CLIENT_SOURCES = path.normalize(path.resolve(__dirname, 'client.plugins'));
    const PATH_HOST_SOURCES = path.normalize(path.resolve(PATH_DEST, 'process'));
    const HOST_IPC_MOD = path.normalize(path.resolve(__dirname, 'node.libs/logviewer.plugin.ipc'));

    task('link-client-libs', function() {
        logo();
        const tasks = [];
        const sandboxPath = path.normalize(path.resolve(__dirname, PATH_CLIENT_SOURCES));
        const sandboxNodeModules = path.normalize(path.resolve(sandboxPath, 'node_modules'));
        const clientLibsPath = path.normalize(path.resolve(__dirname, CLIENT_NPM_LIBS));
        const clientLibsDist = path.normalize(path.resolve(clientLibsPath, 'dist'));
        CLIENT_NPM_LIBS_LIST.forEach((alias) => {
            const clientLib = path.normalize(path.resolve(clientLibsDist, alias));
            const sandboxLibDest = path.normalize(path.resolve(sandboxNodeModules, alias));
            if (fs.existsSync(sandboxLibDest)) {
                console.log(`Project ${sandboxLibDest} is already linked. It will be unlinked before to be linked again.`);
                tasks.push(echo(colors.blue(`unlink: ${sandboxLibDest}`)));
                tasks.push(`rm -rf ${sandboxLibDest} & exit 0`);
            }
            tasks.push(echo(colors.blue(`Coping: ${sandboxLibDest}`)));
            tasks.push(`${getCpCmd()} ${clientLib} ${sandboxLibDest}`);
            tasks.push(`rm -rf ${path.normalize(path.resolve(sandboxPath, 'etc'))}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.build', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist'));
        const clientNodeModules = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/processes/node_modules'));
        const clientPluginFolder = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/processes'));
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(clientNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientNodeModules}`)));
            tasks.push(`rm -rf ${clientNodeModules}`);
            tasks.push(`npm install --prefix ${clientPluginFolder}`);
        }
        tasks.push(`npm run build:processes --prefix ${PATH_CLIENT_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.delivery', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist/processes/*'));
        const clientDest = path.normalize(path.resolve(PATH_DEST, 'render/'));
        if (fs.existsSync(clientDest)) {
            tasks.push(echo(colors.blue(`Remove dest files: ${clientDest}`)));
            tasks.push(`rm -rf ${clientDest}`);
        }
        tasks.push(`mkdir ${clientDest}`);
        tasks.push(`${getCpCmd()} ${clientDist} ${clientDest}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('host.build', function() {
        logo();
        const tasks = [];
        const hostDist = path.normalize(path.resolve(PATH_HOST_SOURCES, 'dist'));
        const hostNodeModules = path.normalize(path.resolve(PATH_HOST_SOURCES, 'node_modules'));
        if (fs.existsSync(hostDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${hostDist}`)));
            tasks.push(`rm -rf ${hostDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(hostNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${hostNodeModules}`)));
            tasks.push(`rm -rf ${hostNodeModules}`);
        }
        if (!fs.existsSync(hostNodeModules)) {
            tasks.push(`npm install --prefix ${PATH_HOST_SOURCES}`);
        }
        tasks.push(`npm run build --prefix ${PATH_HOST_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('compress', function() {
        logo();
        const tasks = [];
        const file = path.normalize(path.resolve(PATH_COMPRESSED_PLUGINS, `processes@0.0.2-${process.platform}.tgz`));
        if (fs.existsSync(file)) {
            tasks.push(echo(colors.blue(`Remove file: ${file}`)));
            tasks.push(`rm -rf ${file}`);
        }
        tasks.push(`tar -cvzf ${file} -C ${path.dirname(PATH_DEST)} ${path.basename(PATH_DEST)}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['plugin.processes:link-client-libs', 'plugin.processes:client.build', 'plugin.processes:client.delivery', 'plugin.processes:host.build', 'plugin.processes:compress']);

});

namespace('plugin.xterminal', function() {
    const PATH_DEST = path.normalize(path.resolve(__dirname, 'sandbox/xterminal'));
    const PATH_CLIENT_SOURCES = path.normalize(path.resolve(__dirname, 'client.plugins'));
    const PATH_HOST_SOURCES = path.normalize(path.resolve(PATH_DEST, 'process'));
    const HOST_IPC_MOD = path.normalize(path.resolve(__dirname, 'node.libs/logviewer.plugin.ipc'));

    task('link-client-libs', function() {
        logo();
        const tasks = [];
        const sandboxPath = path.normalize(path.resolve(__dirname, PATH_CLIENT_SOURCES));
        const sandboxNodeModules = path.normalize(path.resolve(sandboxPath, 'node_modules'));
        const clientLibsPath = path.normalize(path.resolve(__dirname, CLIENT_NPM_LIBS));
        const clientLibsDist = path.normalize(path.resolve(clientLibsPath, 'dist'));
        CLIENT_NPM_LIBS_LIST.forEach((alias) => {
            const clientLib = path.normalize(path.resolve(clientLibsDist, alias));
            const sandboxLibDest = path.normalize(path.resolve(sandboxNodeModules, alias));
            if (fs.existsSync(sandboxLibDest)) {
                console.log(`Project ${sandboxLibDest} is already linked. It will be unlinked before to be linked again.`);
                tasks.push(echo(colors.blue(`unlink: ${sandboxLibDest}`)));
                tasks.push(`rm -rf ${sandboxLibDest} & exit 0`);
            }
            tasks.push(echo(colors.blue(`Coping: ${sandboxLibDest}`)));
            tasks.push(`${getCpCmd()} ${clientLib} ${sandboxLibDest}`);
            tasks.push(`rm -rf ${path.normalize(path.resolve(sandboxPath, 'etc'))}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.build', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist'));
        const clientNodeModules = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/xterminal/node_modules'));
        const clientPluginFolder = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/xterminal'));
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(clientNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientNodeModules}`)));
            tasks.push(`rm -rf ${clientNodeModules}`);
            tasks.push(`npm install --prefix ${clientPluginFolder}`);
        }
        tasks.push(`npm run build:xterminal --prefix ${PATH_CLIENT_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.delivery', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist/xterminal/*'));
        const clientDest = path.normalize(path.resolve(PATH_DEST, 'render/'));
        if (fs.existsSync(clientDest)) {
            tasks.push(echo(colors.blue(`Remove dest files: ${clientDest}`)));
            tasks.push(`rm -rf ${clientDest}`);
        }
        tasks.push(`mkdir ${clientDest}`);
        tasks.push(`${getCpCmd()} ${clientDist} ${clientDest}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('host.build', function() {
        logo();
        const tasks = [];
        const hostDist = path.normalize(path.resolve(PATH_HOST_SOURCES, 'dist'));
        const hostNodeModules = path.normalize(path.resolve(PATH_HOST_SOURCES, 'node_modules'));
        if (fs.existsSync(hostDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${hostDist}`)));
            tasks.push(`rm -rf ${hostDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(hostNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${hostNodeModules}`)));
            tasks.push(`rm -rf ${hostNodeModules}`);
        }
        if (!fs.existsSync(hostNodeModules)) {
            tasks.push(`npm install --prefix ${PATH_HOST_SOURCES}`);
        }
        tasks.push(`npm run build --prefix ${PATH_HOST_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('compress', function() {
        logo();
        const tasks = [];
        const file = path.normalize(path.resolve(PATH_COMPRESSED_PLUGINS, `xterminal@0.0.1-${process.platform}.tgz`));
        if (fs.existsSync(file)) {
            tasks.push(echo(colors.blue(`Remove file: ${file}`)));
            tasks.push(`rm -rf ${file}`);
        }
        tasks.push(`tar -cvzf ${file} -C ${path.dirname(PATH_DEST)} ${path.basename(PATH_DEST)}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['plugin.xterminal:link-client-libs', 'plugin.xterminal:client.build', 'plugin.xterminal:client.delivery', 'plugin.xterminal:host.build', 'plugin.xterminal:compress']);

});

namespace('plugin.dlt', function() {
    const PATH_DEST = path.normalize(path.resolve(__dirname, 'sandbox/dlt'));
    const PATH_CLIENT_SOURCES = path.normalize(path.resolve(__dirname, 'client.plugins'));
    const PATH_HOST_SOURCES = path.normalize(path.resolve(PATH_DEST, 'process'));
    const HOST_IPC_MOD = path.normalize(path.resolve(__dirname, 'node.libs/logviewer.plugin.ipc'));

    task('link-client-libs', function() {
        logo();
        const tasks = [];
        const sandboxPath = path.normalize(path.resolve(__dirname, PATH_CLIENT_SOURCES));
        const sandboxNodeModules = path.normalize(path.resolve(sandboxPath, 'node_modules'));
        const clientLibsPath = path.normalize(path.resolve(__dirname, CLIENT_NPM_LIBS));
        const clientLibsDist = path.normalize(path.resolve(clientLibsPath, 'dist'));
        CLIENT_NPM_LIBS_LIST.forEach((alias) => {
            const clientLib = path.normalize(path.resolve(clientLibsDist, alias));
            const sandboxLibDest = path.normalize(path.resolve(sandboxNodeModules, alias));
            if (fs.existsSync(sandboxLibDest)) {
                console.log(`Project ${sandboxLibDest} is already linked. It will be unlinked before to be linked again.`);
                tasks.push(echo(colors.blue(`unlink: ${sandboxLibDest}`)));
                tasks.push(`rm -rf ${sandboxLibDest} & exit 0`);
            }
            tasks.push(echo(colors.blue(`Coping: ${sandboxLibDest}`)));
            tasks.push(`${getCpCmd()} ${clientLib} ${sandboxLibDest}`);
            tasks.push(`rm -rf ${path.normalize(path.resolve(sandboxPath, 'etc'))}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.build', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist'));
        const clientNodeModules = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/dlt/node_modules'));
        const clientPluginFolder = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/dlt'));
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(clientNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientNodeModules}`)));
            tasks.push(`rm -rf ${clientNodeModules}`);
            tasks.push(`npm install --prefix ${clientPluginFolder}`);
        }
        tasks.push(`npm run build:dlt --prefix ${PATH_CLIENT_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.delivery', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist/dlt/*'));
        const clientDest = path.normalize(path.resolve(PATH_DEST, 'render/'));
        if (fs.existsSync(clientDest)) {
            tasks.push(echo(colors.blue(`Remove dest files: ${clientDest}`)));
            tasks.push(`rm -rf ${clientDest}`);
        }
        tasks.push(`mkdir ${clientDest}`);
        tasks.push(`${getCpCmd()} ${clientDist} ${clientDest}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('host.build', function() {
        logo();
        const tasks = [];
        const hostDist = path.normalize(path.resolve(PATH_HOST_SOURCES, 'dist'));
        const hostNodeModules = path.normalize(path.resolve(PATH_HOST_SOURCES, 'node_modules'));
        if (fs.existsSync(hostDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${hostDist}`)));
            tasks.push(`rm -rf ${hostDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(hostNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${hostNodeModules}`)));
            tasks.push(`rm -rf ${hostNodeModules}`);
        }
        if (!fs.existsSync(hostNodeModules)) {
            tasks.push(`npm install --prefix ${PATH_HOST_SOURCES}`);
        }
        tasks.push(`npm run build --prefix ${PATH_HOST_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('compress', function() {
        logo();
        const tasks = [];
        const file = path.normalize(path.resolve(PATH_COMPRESSED_PLUGINS, `dlt@0.0.1-${process.platform}.tgz`));
        if (fs.existsSync(file)) {
            tasks.push(echo(colors.blue(`Remove file: ${file}`)));
            tasks.push(`rm -rf ${file}`);
        }
        tasks.push(`tar -cvzf ${file} -C ${path.dirname(PATH_DEST)} ${path.basename(PATH_DEST)}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['plugin.dlt:link-client-libs', 'plugin.dlt:client.build', 'plugin.dlt:client.delivery', 'plugin.dlt:host.build', 'plugin.dlt:compress']);

});

namespace('plugin.dlt-render', function() {
    const PATH_DEST = path.normalize(path.resolve(__dirname, 'sandbox/dlt-render'));
    const PATH_CLIENT_SOURCES = path.normalize(path.resolve(__dirname, 'client.plugins'));

    task('link-client-libs', function() {
        logo();
        const tasks = [];
        const sandboxPath = path.normalize(path.resolve(__dirname, PATH_CLIENT_SOURCES));
        const sandboxNodeModules = path.normalize(path.resolve(sandboxPath, 'node_modules'));
        const clientLibsPath = path.normalize(path.resolve(__dirname, CLIENT_NPM_LIBS));
        const clientLibsDist = path.normalize(path.resolve(clientLibsPath, 'dist'));
        CLIENT_NPM_LIBS_LIST.forEach((alias) => {
            const clientLib = path.normalize(path.resolve(clientLibsDist, alias));
            const sandboxLibDest = path.normalize(path.resolve(sandboxNodeModules, alias));
            if (fs.existsSync(sandboxLibDest)) {
                console.log(`Project ${sandboxLibDest} is already linked. It will be unlinked before to be linked again.`);
                tasks.push(echo(colors.blue(`unlink: ${sandboxLibDest}`)));
                tasks.push(`rm -rf ${sandboxLibDest} & exit 0`);
            }
            tasks.push(echo(colors.blue(`Coping: ${sandboxLibDest}`)));
            tasks.push(`${getCpCmd()} ${clientLib} ${sandboxLibDest}`);
            tasks.push(`rm -rf ${path.normalize(path.resolve(sandboxPath, 'etc'))}`);
        });
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.build', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist'));
        const clientNodeModules = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/dlt-render/node_modules'));
        const clientPluginFolder = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'projects/dlt-render'));
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(clientNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientNodeModules}`)));
            tasks.push(`rm -rf ${clientNodeModules}`);
            tasks.push(`npm install --prefix ${clientPluginFolder}`);
        }
        tasks.push(`npm run build:dlt-render --prefix ${PATH_CLIENT_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.delivery', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist/dlt-render/*'));
        const clientDest = path.normalize(path.resolve(PATH_DEST, 'render/'));
        if (fs.existsSync(clientDest)) {
            tasks.push(echo(colors.blue(`Remove dest files: ${clientDest}`)));
            tasks.push(`rm -rf ${clientDest}`);
        }
        tasks.push(`mkdir ${clientDest}`);
        tasks.push(`${getCpCmd()} ${clientDist} ${clientDest}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('compress', function() {
        logo();
        const tasks = [];
        const file = path.normalize(path.resolve(PATH_COMPRESSED_PLUGINS, `dlt-render@0.0.1-${process.platform}.tgz`));
        if (fs.existsSync(file)) {
            tasks.push(echo(colors.blue(`Remove file: ${file}`)));
            tasks.push(`rm -rf ${file}`);
        }
        tasks.push(`tar -cvzf ${file} -C ${path.dirname(PATH_DEST)} ${path.basename(PATH_DEST)}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['plugin.dlt-render:link-client-libs', 'plugin.dlt-render:client.build', 'plugin.dlt-render:client.delivery', 'plugin.dlt-render:compress']);

});

namespace('plugin.row.parser.ascii', function() {
    const PATH_DEST = path.normalize(path.resolve(__dirname, 'sandbox/row.parser.ascii'));
    const PATH_CLIENT_SOURCES = path.normalize(path.resolve(__dirname, 'client.plugins.standalone/row.parser.ascii'));

    task('client.build', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist'));
        const clientNodeModules = path.normalize(path.resolve(PATH_CLIENT_SOURCES, '/node_modules'));
        if (fs.existsSync(clientDist)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientDist}`)));
            tasks.push(`rm -rf ${clientDist}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(clientNodeModules)) {
            tasks.push(echo(colors.blue(`Remove dist files: ${clientNodeModules}`)));
            tasks.push(`rm -rf ${clientNodeModules}`);
            tasks.push(`npm install --prefix ${PATH_CLIENT_SOURCES}`);
        }
        tasks.push(`npm run build --prefix ${PATH_CLIENT_SOURCES}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('client.delivery', function() {
        logo();
        const tasks = [];
        const clientDist = path.normalize(path.resolve(PATH_CLIENT_SOURCES, 'dist/*'));
        const clientDest = path.normalize(path.resolve(PATH_DEST, 'render/dist'));
        if (fs.existsSync(clientDest)) {
            tasks.push(echo(colors.blue(`Remove dest files: ${clientDest}`)));
            tasks.push(`rm -rf ${clientDest}`);
        }
        tasks.push(`mkdir ${clientDest}`);
        tasks.push(`${getCpCmd()} ${clientDist} ${clientDest}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('compress', function() {
        logo();
        const tasks = [];
        const file = path.normalize(path.resolve(PATH_COMPRESSED_PLUGINS, `row.parser.ascii@0.0.1-${process.platform}.tgz`));
        if (fs.existsSync(file)) {
            tasks.push(echo(colors.blue(`Remove file: ${file}`)));
            tasks.push(`rm -rf ${file}`);
        }
        tasks.push(`tar -cvzf ${file} -C ${path.dirname(PATH_DEST)} ${path.basename(PATH_DEST)}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('all', ['plugin.row.parser.ascii:client.build', 'plugin.row.parser.ascii:client.delivery', 'plugin.row.parser.ascii:compress']);

});

namespace('plugins', function() {

    task('all', ['plugin.row.parser.ascii:all', 'plugin.dlt-render:all', 'plugin.dlt:all', 'plugin.xterminal:all', 'plugin.processes:all']);

});

namespace('electron', function() {

    task('install', function() {
        logo();
        const tasks = [];
        const electronAppPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronNodeModules = path.normalize(path.resolve(electronAppPath, 'node_modules'));
        if (!CLI_FLAGS.skipNpm && fs.existsSync(electronNodeModules)) {
            tasks.push(echo(colors.blue(`Remove node_modules files: ${electronNodeModules}`)));
            tasks.push(`rm -rf ${electronNodeModules}`);
        }
        !CLI_FLAGS.skipNpm && tasks.push(echo(colors.blue(`Installing NPM in: ${electronAppPath}`)));
        !CLI_FLAGS.skipNpm && tasks.push(`npm install --prefix ${electronAppPath}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('compile', function() {
        logo();
        const tasks = [];
        const electronAppPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronCompiledFolder = path.normalize(path.resolve(electronAppPath, 'compiled'));
        if (fs.existsSync(electronCompiledFolder)) {
            tasks.push(echo(colors.blue(`Remove compiled files: ${electronCompiledFolder}`)));
            tasks.push(`rm -rf ${electronCompiledFolder}`);
        }
        tasks.push(echo(colors.blue(`Installing NPM in: ${electronAppPath}`)));
        tasks.push(`npm run build-ts`);
        sh(this, electronAppPath, ...tasks);
    }, {async: true});

    task('clean', function() {
        logo();
        const tasks = [];
        const electronAppPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronDistFolder = path.normalize(path.resolve(electronAppPath, 'dist'));
        const electronCompiledFolder = path.normalize(path.resolve(electronDistFolder, 'compiled'));
        const electronNodeModules = path.normalize(path.resolve(electronAppPath, 'node_modules'));
        if (fs.existsSync(electronCompiledFolder)) {
            tasks.push(echo(colors.blue(`Remove compiled files: ${electronCompiledFolder}`)));
            tasks.push(`rm -rf ${electronCompiledFolder}`);
        }
        if (fs.existsSync(electronDistFolder)) {
            tasks.push(echo(colors.blue(`Remove compiled files: ${electronDistFolder}`)));
            tasks.push(`rm -rf ${electronDistFolder}`);
        }
        if (!CLI_FLAGS.skipNpm && fs.existsSync(electronNodeModules)) {
            tasks.push(echo(colors.blue(`Remove compiled files: ${electronNodeModules}`)));
            tasks.push(`rm -rf ${electronNodeModules}`);
        }
        if (tasks.length === 0) {
            return this.complete();
        }
        sh(this, '.', ...tasks);
    }, {async: true});

    task('buildApp', function() {
        logo();
        const tasks = [];
        const electronAppPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronDistFolder = path.normalize(path.resolve(electronAppPath, 'dist'));
        const electronCompiledFolder = path.normalize(path.resolve(electronDistFolder, 'compiled'));
        const platform = os.platform();
        if ([PLATFORMS.darwin, PLATFORMS.linux, PLATFORMS.win32].indexOf(platform) === -1) {
            return new Error(`Unsupportable platform: ${platform}`);
        }
        const prefixes = {
            [PLATFORMS.darwin]: 'mac',
            [PLATFORMS.linux]: 'linux',
            [PLATFORMS.win32]: 'win'
        };
        // Copy package.json
        tasks.push(`cp ${path.normalize(path.resolve(electronAppPath, 'package.json'))} ${path.normalize(path.resolve(electronCompiledFolder, 'package.json'))}`)
        // Build app
        tasks.push(`npm run build-${prefixes[platform]}`);
        sh(this, electronAppPath, ...tasks);
    }, {async: true});

    task('package.json', function() {
        logo();
        const tasks = [];
        const electronAppPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronDistFolder = path.normalize(path.resolve(electronAppPath, 'dist'));
        const electronCompiledFolder = path.normalize(path.resolve(electronDistFolder, 'compiled'));
        // Copy package.json
        tasks.push(`cp ${path.normalize(path.resolve(electronAppPath, 'package.json'))} ${path.normalize(path.resolve(electronCompiledFolder, 'package.json'))}`)
        sh(this, electronAppPath, ...tasks);
    }, {async: true});

    task('deliveryClient', function() {
        logo();
        const tasks = [];
        const clientPath = path.normalize(path.resolve(__dirname, CLIENT_FOLDER));
        const clientDist = path.normalize(path.resolve(clientPath, 'dist/logviewer'));
        const electronAppPath = path.normalize(path.resolve(__dirname, ELECTRON_FOLDER));
        const electronDistFolder = path.normalize(path.resolve(electronAppPath, 'dist/compiled/client'));
        tasks.push(echo(colors.blue(`Delivery client to electron: ${clientDist} to ${electronDistFolder}`)));
        tasks.push(`rm -rf ${electronDistFolder} && exit 0`);
        tasks.push(`${getCpCmd()} ${clientDist} ${electronDistFolder}`);
        sh(this, '.', ...tasks);
    }, {async: true});

    task('build', ['electron:clean', 'solution:link', 'solution:fix-npm-etc', 'electron:install', 'electron:compile', 'client:all', 'electron:deliveryClient', 'plugin.processes:all', 'plugin.xterminal:all', 'plugin.file:all', 'electron:buildApp']);
    task('prebuild', ['electron:clean', 'solution:link', 'solution:fix-npm-etc', 'electron:install', 'electron:compile', 'client:all', 'electron:deliveryClient', 'plugin.processes:all', 'plugin.xterminal:all', 'plugin.file:all', 'electron:package.json']);
    task('quick', ['client:build', 'electron:deliveryClient', 'electron:package.json']);

});
